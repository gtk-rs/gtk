// This file was generated by gir (c3b4020) from gir-files (71d73f0)
// DO NOT EDIT

use ffi;
use glib_ffi;
use glib::error::ErrorDomain;
use glib::translate::*;

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum Align {
    Fill,
    Start,
    End,
    Center,
    Baseline,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for Align {
    type GlibType = ffi::GtkAlign;

    fn to_glib(&self) -> ffi::GtkAlign {
        match *self {
            Align::Fill => ffi::GTK_ALIGN_FILL,
            Align::Start => ffi::GTK_ALIGN_START,
            Align::End => ffi::GTK_ALIGN_END,
            Align::Center => ffi::GTK_ALIGN_CENTER,
            Align::Baseline => ffi::GTK_ALIGN_BASELINE,
            Align::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkAlign> for Align {
    fn from_glib(value: ffi::GtkAlign) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_ALIGN_FILL => Align::Fill,
            ffi::GTK_ALIGN_START => Align::Start,
            ffi::GTK_ALIGN_END => Align::End,
            ffi::GTK_ALIGN_CENTER => Align::Center,
            ffi::GTK_ALIGN_BASELINE => Align::Baseline,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ArrowType {
    Up,
    Down,
    Left,
    Right,
    None,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for ArrowType {
    type GlibType = ffi::GtkArrowType;

    fn to_glib(&self) -> ffi::GtkArrowType {
        match *self {
            ArrowType::Up => ffi::GTK_ARROW_UP,
            ArrowType::Down => ffi::GTK_ARROW_DOWN,
            ArrowType::Left => ffi::GTK_ARROW_LEFT,
            ArrowType::Right => ffi::GTK_ARROW_RIGHT,
            ArrowType::None => ffi::GTK_ARROW_NONE,
            ArrowType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkArrowType> for ArrowType {
    fn from_glib(value: ffi::GtkArrowType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_ARROW_UP => ArrowType::Up,
            ffi::GTK_ARROW_DOWN => ArrowType::Down,
            ffi::GTK_ARROW_LEFT => ArrowType::Left,
            ffi::GTK_ARROW_RIGHT => ArrowType::Right,
            ffi::GTK_ARROW_NONE => ArrowType::None,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum AssistantPageType {
    Content,
    Intro,
    Confirm,
    Summary,
    Progress,
    Custom,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for AssistantPageType {
    type GlibType = ffi::GtkAssistantPageType;

    fn to_glib(&self) -> ffi::GtkAssistantPageType {
        match *self {
            AssistantPageType::Content => ffi::GTK_ASSISTANT_PAGE_CONTENT,
            AssistantPageType::Intro => ffi::GTK_ASSISTANT_PAGE_INTRO,
            AssistantPageType::Confirm => ffi::GTK_ASSISTANT_PAGE_CONFIRM,
            AssistantPageType::Summary => ffi::GTK_ASSISTANT_PAGE_SUMMARY,
            AssistantPageType::Progress => ffi::GTK_ASSISTANT_PAGE_PROGRESS,
            AssistantPageType::Custom => ffi::GTK_ASSISTANT_PAGE_CUSTOM,
            AssistantPageType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkAssistantPageType> for AssistantPageType {
    fn from_glib(value: ffi::GtkAssistantPageType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_ASSISTANT_PAGE_CONTENT => AssistantPageType::Content,
            ffi::GTK_ASSISTANT_PAGE_INTRO => AssistantPageType::Intro,
            ffi::GTK_ASSISTANT_PAGE_CONFIRM => AssistantPageType::Confirm,
            ffi::GTK_ASSISTANT_PAGE_SUMMARY => AssistantPageType::Summary,
            ffi::GTK_ASSISTANT_PAGE_PROGRESS => AssistantPageType::Progress,
            ffi::GTK_ASSISTANT_PAGE_CUSTOM => AssistantPageType::Custom,
        }
    }
}

#[cfg(feature = "v3_10")]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum BaselinePosition {
    Top,
    Center,
    Bottom,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[cfg(feature = "v3_10")]
#[doc(hidden)]
impl ToGlib for BaselinePosition {
    type GlibType = ffi::GtkBaselinePosition;

    fn to_glib(&self) -> ffi::GtkBaselinePosition {
        match *self {
            BaselinePosition::Top => ffi::GTK_BASELINE_POSITION_TOP,
            BaselinePosition::Center => ffi::GTK_BASELINE_POSITION_CENTER,
            BaselinePosition::Bottom => ffi::GTK_BASELINE_POSITION_BOTTOM,
            BaselinePosition::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[cfg(feature = "v3_10")]
#[doc(hidden)]
impl FromGlib<ffi::GtkBaselinePosition> for BaselinePosition {
    fn from_glib(value: ffi::GtkBaselinePosition) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_BASELINE_POSITION_TOP => BaselinePosition::Top,
            ffi::GTK_BASELINE_POSITION_CENTER => BaselinePosition::Center,
            ffi::GTK_BASELINE_POSITION_BOTTOM => BaselinePosition::Bottom,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum BuilderError {
    InvalidTypeFunction,
    UnhandledTag,
    MissingAttribute,
    InvalidAttribute,
    InvalidTag,
    MissingPropertyValue,
    InvalidValue,
    VersionMismatch,
    DuplicateId,
    ObjectTypeRefused,
    TemplateMismatch,
    InvalidProperty,
    InvalidSignal,
    InvalidId,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for BuilderError {
    type GlibType = ffi::GtkBuilderError;

    fn to_glib(&self) -> ffi::GtkBuilderError {
        match *self {
            BuilderError::InvalidTypeFunction => ffi::GTK_BUILDER_ERROR_INVALID_TYPE_FUNCTION,
            BuilderError::UnhandledTag => ffi::GTK_BUILDER_ERROR_UNHANDLED_TAG,
            BuilderError::MissingAttribute => ffi::GTK_BUILDER_ERROR_MISSING_ATTRIBUTE,
            BuilderError::InvalidAttribute => ffi::GTK_BUILDER_ERROR_INVALID_ATTRIBUTE,
            BuilderError::InvalidTag => ffi::GTK_BUILDER_ERROR_INVALID_TAG,
            BuilderError::MissingPropertyValue => ffi::GTK_BUILDER_ERROR_MISSING_PROPERTY_VALUE,
            BuilderError::InvalidValue => ffi::GTK_BUILDER_ERROR_INVALID_VALUE,
            BuilderError::VersionMismatch => ffi::GTK_BUILDER_ERROR_VERSION_MISMATCH,
            BuilderError::DuplicateId => ffi::GTK_BUILDER_ERROR_DUPLICATE_ID,
            BuilderError::ObjectTypeRefused => ffi::GTK_BUILDER_ERROR_OBJECT_TYPE_REFUSED,
            BuilderError::TemplateMismatch => ffi::GTK_BUILDER_ERROR_TEMPLATE_MISMATCH,
            BuilderError::InvalidProperty => ffi::GTK_BUILDER_ERROR_INVALID_PROPERTY,
            BuilderError::InvalidSignal => ffi::GTK_BUILDER_ERROR_INVALID_SIGNAL,
            BuilderError::InvalidId => ffi::GTK_BUILDER_ERROR_INVALID_ID,
            BuilderError::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkBuilderError> for BuilderError {
    fn from_glib(value: ffi::GtkBuilderError) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_BUILDER_ERROR_INVALID_TYPE_FUNCTION => BuilderError::InvalidTypeFunction,
            ffi::GTK_BUILDER_ERROR_UNHANDLED_TAG => BuilderError::UnhandledTag,
            ffi::GTK_BUILDER_ERROR_MISSING_ATTRIBUTE => BuilderError::MissingAttribute,
            ffi::GTK_BUILDER_ERROR_INVALID_ATTRIBUTE => BuilderError::InvalidAttribute,
            ffi::GTK_BUILDER_ERROR_INVALID_TAG => BuilderError::InvalidTag,
            ffi::GTK_BUILDER_ERROR_MISSING_PROPERTY_VALUE => BuilderError::MissingPropertyValue,
            ffi::GTK_BUILDER_ERROR_INVALID_VALUE => BuilderError::InvalidValue,
            ffi::GTK_BUILDER_ERROR_VERSION_MISMATCH => BuilderError::VersionMismatch,
            ffi::GTK_BUILDER_ERROR_DUPLICATE_ID => BuilderError::DuplicateId,
            ffi::GTK_BUILDER_ERROR_OBJECT_TYPE_REFUSED => BuilderError::ObjectTypeRefused,
            ffi::GTK_BUILDER_ERROR_TEMPLATE_MISMATCH => BuilderError::TemplateMismatch,
            ffi::GTK_BUILDER_ERROR_INVALID_PROPERTY => BuilderError::InvalidProperty,
            ffi::GTK_BUILDER_ERROR_INVALID_SIGNAL => BuilderError::InvalidSignal,
            ffi::GTK_BUILDER_ERROR_INVALID_ID => BuilderError::InvalidId,
        }
    }
}

impl ErrorDomain for BuilderError {
    fn domain() -> glib_ffi::GQuark {
        skip_assert_initialized!();
        unsafe { ffi::gtk_builder_error_quark() }
    }

    fn code(self) -> i32 {
        self.to_glib() as i32
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            x if x == ffi::GTK_BUILDER_ERROR_INVALID_TYPE_FUNCTION as i32 => Some(BuilderError::InvalidTypeFunction),
            x if x == ffi::GTK_BUILDER_ERROR_UNHANDLED_TAG as i32 => Some(BuilderError::UnhandledTag),
            x if x == ffi::GTK_BUILDER_ERROR_MISSING_ATTRIBUTE as i32 => Some(BuilderError::MissingAttribute),
            x if x == ffi::GTK_BUILDER_ERROR_INVALID_ATTRIBUTE as i32 => Some(BuilderError::InvalidAttribute),
            x if x == ffi::GTK_BUILDER_ERROR_INVALID_TAG as i32 => Some(BuilderError::InvalidTag),
            x if x == ffi::GTK_BUILDER_ERROR_MISSING_PROPERTY_VALUE as i32 => Some(BuilderError::MissingPropertyValue),
            x if x == ffi::GTK_BUILDER_ERROR_INVALID_VALUE as i32 => Some(BuilderError::InvalidValue),
            x if x == ffi::GTK_BUILDER_ERROR_VERSION_MISMATCH as i32 => Some(BuilderError::VersionMismatch),
            x if x == ffi::GTK_BUILDER_ERROR_DUPLICATE_ID as i32 => Some(BuilderError::DuplicateId),
            x if x == ffi::GTK_BUILDER_ERROR_OBJECT_TYPE_REFUSED as i32 => Some(BuilderError::ObjectTypeRefused),
            x if x == ffi::GTK_BUILDER_ERROR_TEMPLATE_MISMATCH as i32 => Some(BuilderError::TemplateMismatch),
            x if x == ffi::GTK_BUILDER_ERROR_INVALID_PROPERTY as i32 => Some(BuilderError::InvalidProperty),
            x if x == ffi::GTK_BUILDER_ERROR_INVALID_SIGNAL as i32 => Some(BuilderError::InvalidSignal),
            x if x == ffi::GTK_BUILDER_ERROR_INVALID_ID as i32 => Some(BuilderError::InvalidId),
            _ => Some(BuilderError::__Nonexhaustive(())),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ButtonBoxStyle {
    Spread,
    Edge,
    Start,
    End,
    Center,
    Expand,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for ButtonBoxStyle {
    type GlibType = ffi::GtkButtonBoxStyle;

    fn to_glib(&self) -> ffi::GtkButtonBoxStyle {
        match *self {
            ButtonBoxStyle::Spread => ffi::GTK_BUTTONBOX_SPREAD,
            ButtonBoxStyle::Edge => ffi::GTK_BUTTONBOX_EDGE,
            ButtonBoxStyle::Start => ffi::GTK_BUTTONBOX_START,
            ButtonBoxStyle::End => ffi::GTK_BUTTONBOX_END,
            ButtonBoxStyle::Center => ffi::GTK_BUTTONBOX_CENTER,
            ButtonBoxStyle::Expand => ffi::GTK_BUTTONBOX_EXPAND,
            ButtonBoxStyle::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkButtonBoxStyle> for ButtonBoxStyle {
    fn from_glib(value: ffi::GtkButtonBoxStyle) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_BUTTONBOX_SPREAD => ButtonBoxStyle::Spread,
            ffi::GTK_BUTTONBOX_EDGE => ButtonBoxStyle::Edge,
            ffi::GTK_BUTTONBOX_START => ButtonBoxStyle::Start,
            ffi::GTK_BUTTONBOX_END => ButtonBoxStyle::End,
            ffi::GTK_BUTTONBOX_CENTER => ButtonBoxStyle::Center,
            ffi::GTK_BUTTONBOX_EXPAND => ButtonBoxStyle::Expand,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ButtonRole {
    Normal,
    Check,
    Radio,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for ButtonRole {
    type GlibType = ffi::GtkButtonRole;

    fn to_glib(&self) -> ffi::GtkButtonRole {
        match *self {
            ButtonRole::Normal => ffi::GTK_BUTTON_ROLE_NORMAL,
            ButtonRole::Check => ffi::GTK_BUTTON_ROLE_CHECK,
            ButtonRole::Radio => ffi::GTK_BUTTON_ROLE_RADIO,
            ButtonRole::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkButtonRole> for ButtonRole {
    fn from_glib(value: ffi::GtkButtonRole) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_BUTTON_ROLE_NORMAL => ButtonRole::Normal,
            ffi::GTK_BUTTON_ROLE_CHECK => ButtonRole::Check,
            ffi::GTK_BUTTON_ROLE_RADIO => ButtonRole::Radio,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ButtonsType {
    None,
    Ok,
    Close,
    Cancel,
    YesNo,
    OkCancel,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for ButtonsType {
    type GlibType = ffi::GtkButtonsType;

    fn to_glib(&self) -> ffi::GtkButtonsType {
        match *self {
            ButtonsType::None => ffi::GTK_BUTTONS_NONE,
            ButtonsType::Ok => ffi::GTK_BUTTONS_OK,
            ButtonsType::Close => ffi::GTK_BUTTONS_CLOSE,
            ButtonsType::Cancel => ffi::GTK_BUTTONS_CANCEL,
            ButtonsType::YesNo => ffi::GTK_BUTTONS_YES_NO,
            ButtonsType::OkCancel => ffi::GTK_BUTTONS_OK_CANCEL,
            ButtonsType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkButtonsType> for ButtonsType {
    fn from_glib(value: ffi::GtkButtonsType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_BUTTONS_NONE => ButtonsType::None,
            ffi::GTK_BUTTONS_OK => ButtonsType::Ok,
            ffi::GTK_BUTTONS_CLOSE => ButtonsType::Close,
            ffi::GTK_BUTTONS_CANCEL => ButtonsType::Cancel,
            ffi::GTK_BUTTONS_YES_NO => ButtonsType::YesNo,
            ffi::GTK_BUTTONS_OK_CANCEL => ButtonsType::OkCancel,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum CellRendererAccelMode {
    Gtk,
    Other,
    ModifierTap,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for CellRendererAccelMode {
    type GlibType = ffi::GtkCellRendererAccelMode;

    fn to_glib(&self) -> ffi::GtkCellRendererAccelMode {
        match *self {
            CellRendererAccelMode::Gtk => ffi::GTK_CELL_RENDERER_ACCEL_MODE_GTK,
            CellRendererAccelMode::Other => ffi::GTK_CELL_RENDERER_ACCEL_MODE_OTHER,
            CellRendererAccelMode::ModifierTap => ffi::GTK_CELL_RENDERER_ACCEL_MODE_MODIFIER_TAP,
            CellRendererAccelMode::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCellRendererAccelMode> for CellRendererAccelMode {
    fn from_glib(value: ffi::GtkCellRendererAccelMode) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_CELL_RENDERER_ACCEL_MODE_GTK => CellRendererAccelMode::Gtk,
            ffi::GTK_CELL_RENDERER_ACCEL_MODE_OTHER => CellRendererAccelMode::Other,
            ffi::GTK_CELL_RENDERER_ACCEL_MODE_MODIFIER_TAP => CellRendererAccelMode::ModifierTap,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum CellRendererMode {
    Inert,
    Activatable,
    Editable,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for CellRendererMode {
    type GlibType = ffi::GtkCellRendererMode;

    fn to_glib(&self) -> ffi::GtkCellRendererMode {
        match *self {
            CellRendererMode::Inert => ffi::GTK_CELL_RENDERER_MODE_INERT,
            CellRendererMode::Activatable => ffi::GTK_CELL_RENDERER_MODE_ACTIVATABLE,
            CellRendererMode::Editable => ffi::GTK_CELL_RENDERER_MODE_EDITABLE,
            CellRendererMode::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCellRendererMode> for CellRendererMode {
    fn from_glib(value: ffi::GtkCellRendererMode) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_CELL_RENDERER_MODE_INERT => CellRendererMode::Inert,
            ffi::GTK_CELL_RENDERER_MODE_ACTIVATABLE => CellRendererMode::Activatable,
            ffi::GTK_CELL_RENDERER_MODE_EDITABLE => CellRendererMode::Editable,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum CornerType {
    TopLeft,
    BottomLeft,
    TopRight,
    BottomRight,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for CornerType {
    type GlibType = ffi::GtkCornerType;

    fn to_glib(&self) -> ffi::GtkCornerType {
        match *self {
            CornerType::TopLeft => ffi::GTK_CORNER_TOP_LEFT,
            CornerType::BottomLeft => ffi::GTK_CORNER_BOTTOM_LEFT,
            CornerType::TopRight => ffi::GTK_CORNER_TOP_RIGHT,
            CornerType::BottomRight => ffi::GTK_CORNER_BOTTOM_RIGHT,
            CornerType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCornerType> for CornerType {
    fn from_glib(value: ffi::GtkCornerType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_CORNER_TOP_LEFT => CornerType::TopLeft,
            ffi::GTK_CORNER_BOTTOM_LEFT => CornerType::BottomLeft,
            ffi::GTK_CORNER_TOP_RIGHT => CornerType::TopRight,
            ffi::GTK_CORNER_BOTTOM_RIGHT => CornerType::BottomRight,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum CssProviderError {
    Failed,
    Syntax,
    Import,
    Name,
    Deprecated,
    UnknownValue,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for CssProviderError {
    type GlibType = ffi::GtkCssProviderError;

    fn to_glib(&self) -> ffi::GtkCssProviderError {
        match *self {
            CssProviderError::Failed => ffi::GTK_CSS_PROVIDER_ERROR_FAILED,
            CssProviderError::Syntax => ffi::GTK_CSS_PROVIDER_ERROR_SYNTAX,
            CssProviderError::Import => ffi::GTK_CSS_PROVIDER_ERROR_IMPORT,
            CssProviderError::Name => ffi::GTK_CSS_PROVIDER_ERROR_NAME,
            CssProviderError::Deprecated => ffi::GTK_CSS_PROVIDER_ERROR_DEPRECATED,
            CssProviderError::UnknownValue => ffi::GTK_CSS_PROVIDER_ERROR_UNKNOWN_VALUE,
            CssProviderError::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCssProviderError> for CssProviderError {
    fn from_glib(value: ffi::GtkCssProviderError) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_CSS_PROVIDER_ERROR_FAILED => CssProviderError::Failed,
            ffi::GTK_CSS_PROVIDER_ERROR_SYNTAX => CssProviderError::Syntax,
            ffi::GTK_CSS_PROVIDER_ERROR_IMPORT => CssProviderError::Import,
            ffi::GTK_CSS_PROVIDER_ERROR_NAME => CssProviderError::Name,
            ffi::GTK_CSS_PROVIDER_ERROR_DEPRECATED => CssProviderError::Deprecated,
            ffi::GTK_CSS_PROVIDER_ERROR_UNKNOWN_VALUE => CssProviderError::UnknownValue,
        }
    }
}

impl ErrorDomain for CssProviderError {
    fn domain() -> glib_ffi::GQuark {
        skip_assert_initialized!();
        unsafe { ffi::gtk_css_provider_error_quark() }
    }

    fn code(self) -> i32 {
        self.to_glib() as i32
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            x if x == ffi::GTK_CSS_PROVIDER_ERROR_FAILED as i32 => Some(CssProviderError::Failed),
            x if x == ffi::GTK_CSS_PROVIDER_ERROR_SYNTAX as i32 => Some(CssProviderError::Syntax),
            x if x == ffi::GTK_CSS_PROVIDER_ERROR_IMPORT as i32 => Some(CssProviderError::Import),
            x if x == ffi::GTK_CSS_PROVIDER_ERROR_NAME as i32 => Some(CssProviderError::Name),
            x if x == ffi::GTK_CSS_PROVIDER_ERROR_DEPRECATED as i32 => Some(CssProviderError::Deprecated),
            x if x == ffi::GTK_CSS_PROVIDER_ERROR_UNKNOWN_VALUE as i32 => Some(CssProviderError::UnknownValue),
            _ => Some(CssProviderError::Failed),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum CssSectionType {
    Document,
    Import,
    ColorDefinition,
    BindingSet,
    Ruleset,
    Selector,
    Declaration,
    Value,
    Keyframes,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for CssSectionType {
    type GlibType = ffi::GtkCssSectionType;

    fn to_glib(&self) -> ffi::GtkCssSectionType {
        match *self {
            CssSectionType::Document => ffi::GTK_CSS_SECTION_DOCUMENT,
            CssSectionType::Import => ffi::GTK_CSS_SECTION_IMPORT,
            CssSectionType::ColorDefinition => ffi::GTK_CSS_SECTION_COLOR_DEFINITION,
            CssSectionType::BindingSet => ffi::GTK_CSS_SECTION_BINDING_SET,
            CssSectionType::Ruleset => ffi::GTK_CSS_SECTION_RULESET,
            CssSectionType::Selector => ffi::GTK_CSS_SECTION_SELECTOR,
            CssSectionType::Declaration => ffi::GTK_CSS_SECTION_DECLARATION,
            CssSectionType::Value => ffi::GTK_CSS_SECTION_VALUE,
            CssSectionType::Keyframes => ffi::GTK_CSS_SECTION_KEYFRAMES,
            CssSectionType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkCssSectionType> for CssSectionType {
    fn from_glib(value: ffi::GtkCssSectionType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_CSS_SECTION_DOCUMENT => CssSectionType::Document,
            ffi::GTK_CSS_SECTION_IMPORT => CssSectionType::Import,
            ffi::GTK_CSS_SECTION_COLOR_DEFINITION => CssSectionType::ColorDefinition,
            ffi::GTK_CSS_SECTION_BINDING_SET => CssSectionType::BindingSet,
            ffi::GTK_CSS_SECTION_RULESET => CssSectionType::Ruleset,
            ffi::GTK_CSS_SECTION_SELECTOR => CssSectionType::Selector,
            ffi::GTK_CSS_SECTION_DECLARATION => CssSectionType::Declaration,
            ffi::GTK_CSS_SECTION_VALUE => CssSectionType::Value,
            ffi::GTK_CSS_SECTION_KEYFRAMES => CssSectionType::Keyframes,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum DeleteType {
    Chars,
    WordEnds,
    Words,
    DisplayLines,
    DisplayLineEnds,
    ParagraphEnds,
    Paragraphs,
    Whitespace,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for DeleteType {
    type GlibType = ffi::GtkDeleteType;

    fn to_glib(&self) -> ffi::GtkDeleteType {
        match *self {
            DeleteType::Chars => ffi::GTK_DELETE_CHARS,
            DeleteType::WordEnds => ffi::GTK_DELETE_WORD_ENDS,
            DeleteType::Words => ffi::GTK_DELETE_WORDS,
            DeleteType::DisplayLines => ffi::GTK_DELETE_DISPLAY_LINES,
            DeleteType::DisplayLineEnds => ffi::GTK_DELETE_DISPLAY_LINE_ENDS,
            DeleteType::ParagraphEnds => ffi::GTK_DELETE_PARAGRAPH_ENDS,
            DeleteType::Paragraphs => ffi::GTK_DELETE_PARAGRAPHS,
            DeleteType::Whitespace => ffi::GTK_DELETE_WHITESPACE,
            DeleteType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkDeleteType> for DeleteType {
    fn from_glib(value: ffi::GtkDeleteType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_DELETE_CHARS => DeleteType::Chars,
            ffi::GTK_DELETE_WORD_ENDS => DeleteType::WordEnds,
            ffi::GTK_DELETE_WORDS => DeleteType::Words,
            ffi::GTK_DELETE_DISPLAY_LINES => DeleteType::DisplayLines,
            ffi::GTK_DELETE_DISPLAY_LINE_ENDS => DeleteType::DisplayLineEnds,
            ffi::GTK_DELETE_PARAGRAPH_ENDS => DeleteType::ParagraphEnds,
            ffi::GTK_DELETE_PARAGRAPHS => DeleteType::Paragraphs,
            ffi::GTK_DELETE_WHITESPACE => DeleteType::Whitespace,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum DirectionType {
    TabForward,
    TabBackward,
    Up,
    Down,
    Left,
    Right,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for DirectionType {
    type GlibType = ffi::GtkDirectionType;

    fn to_glib(&self) -> ffi::GtkDirectionType {
        match *self {
            DirectionType::TabForward => ffi::GTK_DIR_TAB_FORWARD,
            DirectionType::TabBackward => ffi::GTK_DIR_TAB_BACKWARD,
            DirectionType::Up => ffi::GTK_DIR_UP,
            DirectionType::Down => ffi::GTK_DIR_DOWN,
            DirectionType::Left => ffi::GTK_DIR_LEFT,
            DirectionType::Right => ffi::GTK_DIR_RIGHT,
            DirectionType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkDirectionType> for DirectionType {
    fn from_glib(value: ffi::GtkDirectionType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_DIR_TAB_FORWARD => DirectionType::TabForward,
            ffi::GTK_DIR_TAB_BACKWARD => DirectionType::TabBackward,
            ffi::GTK_DIR_UP => DirectionType::Up,
            ffi::GTK_DIR_DOWN => DirectionType::Down,
            ffi::GTK_DIR_LEFT => DirectionType::Left,
            ffi::GTK_DIR_RIGHT => DirectionType::Right,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum DragResult {
    Success,
    NoTarget,
    UserCancelled,
    TimeoutExpired,
    GrabBroken,
    Error,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for DragResult {
    type GlibType = ffi::GtkDragResult;

    fn to_glib(&self) -> ffi::GtkDragResult {
        match *self {
            DragResult::Success => ffi::GTK_DRAG_RESULT_SUCCESS,
            DragResult::NoTarget => ffi::GTK_DRAG_RESULT_NO_TARGET,
            DragResult::UserCancelled => ffi::GTK_DRAG_RESULT_USER_CANCELLED,
            DragResult::TimeoutExpired => ffi::GTK_DRAG_RESULT_TIMEOUT_EXPIRED,
            DragResult::GrabBroken => ffi::GTK_DRAG_RESULT_GRAB_BROKEN,
            DragResult::Error => ffi::GTK_DRAG_RESULT_ERROR,
            DragResult::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkDragResult> for DragResult {
    fn from_glib(value: ffi::GtkDragResult) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_DRAG_RESULT_SUCCESS => DragResult::Success,
            ffi::GTK_DRAG_RESULT_NO_TARGET => DragResult::NoTarget,
            ffi::GTK_DRAG_RESULT_USER_CANCELLED => DragResult::UserCancelled,
            ffi::GTK_DRAG_RESULT_TIMEOUT_EXPIRED => DragResult::TimeoutExpired,
            ffi::GTK_DRAG_RESULT_GRAB_BROKEN => DragResult::GrabBroken,
            ffi::GTK_DRAG_RESULT_ERROR => DragResult::Error,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum EntryIconPosition {
    Primary,
    Secondary,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for EntryIconPosition {
    type GlibType = ffi::GtkEntryIconPosition;

    fn to_glib(&self) -> ffi::GtkEntryIconPosition {
        match *self {
            EntryIconPosition::Primary => ffi::GTK_ENTRY_ICON_PRIMARY,
            EntryIconPosition::Secondary => ffi::GTK_ENTRY_ICON_SECONDARY,
            EntryIconPosition::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkEntryIconPosition> for EntryIconPosition {
    fn from_glib(value: ffi::GtkEntryIconPosition) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_ENTRY_ICON_PRIMARY => EntryIconPosition::Primary,
            ffi::GTK_ENTRY_ICON_SECONDARY => EntryIconPosition::Secondary,
        }
    }
}

#[cfg(feature = "v3_14")]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum EventSequenceState {
    None,
    Claimed,
    Denied,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[cfg(feature = "v3_14")]
#[doc(hidden)]
impl ToGlib for EventSequenceState {
    type GlibType = ffi::GtkEventSequenceState;

    fn to_glib(&self) -> ffi::GtkEventSequenceState {
        match *self {
            EventSequenceState::None => ffi::GTK_EVENT_SEQUENCE_NONE,
            EventSequenceState::Claimed => ffi::GTK_EVENT_SEQUENCE_CLAIMED,
            EventSequenceState::Denied => ffi::GTK_EVENT_SEQUENCE_DENIED,
            EventSequenceState::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[cfg(feature = "v3_14")]
#[doc(hidden)]
impl FromGlib<ffi::GtkEventSequenceState> for EventSequenceState {
    fn from_glib(value: ffi::GtkEventSequenceState) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_EVENT_SEQUENCE_NONE => EventSequenceState::None,
            ffi::GTK_EVENT_SEQUENCE_CLAIMED => EventSequenceState::Claimed,
            ffi::GTK_EVENT_SEQUENCE_DENIED => EventSequenceState::Denied,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum FileChooserAction {
    Open,
    Save,
    SelectFolder,
    CreateFolder,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for FileChooserAction {
    type GlibType = ffi::GtkFileChooserAction;

    fn to_glib(&self) -> ffi::GtkFileChooserAction {
        match *self {
            FileChooserAction::Open => ffi::GTK_FILE_CHOOSER_ACTION_OPEN,
            FileChooserAction::Save => ffi::GTK_FILE_CHOOSER_ACTION_SAVE,
            FileChooserAction::SelectFolder => ffi::GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER,
            FileChooserAction::CreateFolder => ffi::GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER,
            FileChooserAction::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkFileChooserAction> for FileChooserAction {
    fn from_glib(value: ffi::GtkFileChooserAction) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_FILE_CHOOSER_ACTION_OPEN => FileChooserAction::Open,
            ffi::GTK_FILE_CHOOSER_ACTION_SAVE => FileChooserAction::Save,
            ffi::GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER => FileChooserAction::SelectFolder,
            ffi::GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER => FileChooserAction::CreateFolder,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum FileChooserConfirmation {
    Confirm,
    AcceptFilename,
    SelectAgain,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for FileChooserConfirmation {
    type GlibType = ffi::GtkFileChooserConfirmation;

    fn to_glib(&self) -> ffi::GtkFileChooserConfirmation {
        match *self {
            FileChooserConfirmation::Confirm => ffi::GTK_FILE_CHOOSER_CONFIRMATION_CONFIRM,
            FileChooserConfirmation::AcceptFilename => ffi::GTK_FILE_CHOOSER_CONFIRMATION_ACCEPT_FILENAME,
            FileChooserConfirmation::SelectAgain => ffi::GTK_FILE_CHOOSER_CONFIRMATION_SELECT_AGAIN,
            FileChooserConfirmation::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkFileChooserConfirmation> for FileChooserConfirmation {
    fn from_glib(value: ffi::GtkFileChooserConfirmation) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_FILE_CHOOSER_CONFIRMATION_CONFIRM => FileChooserConfirmation::Confirm,
            ffi::GTK_FILE_CHOOSER_CONFIRMATION_ACCEPT_FILENAME => FileChooserConfirmation::AcceptFilename,
            ffi::GTK_FILE_CHOOSER_CONFIRMATION_SELECT_AGAIN => FileChooserConfirmation::SelectAgain,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum FileChooserError {
    Nonexistent,
    BadFilename,
    AlreadyExists,
    IncompleteHostname,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for FileChooserError {
    type GlibType = ffi::GtkFileChooserError;

    fn to_glib(&self) -> ffi::GtkFileChooserError {
        match *self {
            FileChooserError::Nonexistent => ffi::GTK_FILE_CHOOSER_ERROR_NONEXISTENT,
            FileChooserError::BadFilename => ffi::GTK_FILE_CHOOSER_ERROR_BAD_FILENAME,
            FileChooserError::AlreadyExists => ffi::GTK_FILE_CHOOSER_ERROR_ALREADY_EXISTS,
            FileChooserError::IncompleteHostname => ffi::GTK_FILE_CHOOSER_ERROR_INCOMPLETE_HOSTNAME,
            FileChooserError::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkFileChooserError> for FileChooserError {
    fn from_glib(value: ffi::GtkFileChooserError) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_FILE_CHOOSER_ERROR_NONEXISTENT => FileChooserError::Nonexistent,
            ffi::GTK_FILE_CHOOSER_ERROR_BAD_FILENAME => FileChooserError::BadFilename,
            ffi::GTK_FILE_CHOOSER_ERROR_ALREADY_EXISTS => FileChooserError::AlreadyExists,
            ffi::GTK_FILE_CHOOSER_ERROR_INCOMPLETE_HOSTNAME => FileChooserError::IncompleteHostname,
        }
    }
}

impl ErrorDomain for FileChooserError {
    fn domain() -> glib_ffi::GQuark {
        skip_assert_initialized!();
        unsafe { ffi::gtk_file_chooser_error_quark() }
    }

    fn code(self) -> i32 {
        self.to_glib() as i32
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            x if x == ffi::GTK_FILE_CHOOSER_ERROR_NONEXISTENT as i32 => Some(FileChooserError::Nonexistent),
            x if x == ffi::GTK_FILE_CHOOSER_ERROR_BAD_FILENAME as i32 => Some(FileChooserError::BadFilename),
            x if x == ffi::GTK_FILE_CHOOSER_ERROR_ALREADY_EXISTS as i32 => Some(FileChooserError::AlreadyExists),
            x if x == ffi::GTK_FILE_CHOOSER_ERROR_INCOMPLETE_HOSTNAME as i32 => Some(FileChooserError::IncompleteHostname),
            _ => Some(FileChooserError::__Nonexhaustive(())),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum IMPreeditStyle {
    Nothing,
    Callback,
    None,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for IMPreeditStyle {
    type GlibType = ffi::GtkIMPreeditStyle;

    fn to_glib(&self) -> ffi::GtkIMPreeditStyle {
        match *self {
            IMPreeditStyle::Nothing => ffi::GTK_IM_PREEDIT_NOTHING,
            IMPreeditStyle::Callback => ffi::GTK_IM_PREEDIT_CALLBACK,
            IMPreeditStyle::None => ffi::GTK_IM_PREEDIT_NONE,
            IMPreeditStyle::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkIMPreeditStyle> for IMPreeditStyle {
    fn from_glib(value: ffi::GtkIMPreeditStyle) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_IM_PREEDIT_NOTHING => IMPreeditStyle::Nothing,
            ffi::GTK_IM_PREEDIT_CALLBACK => IMPreeditStyle::Callback,
            ffi::GTK_IM_PREEDIT_NONE => IMPreeditStyle::None,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum IMStatusStyle {
    Nothing,
    Callback,
    None,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for IMStatusStyle {
    type GlibType = ffi::GtkIMStatusStyle;

    fn to_glib(&self) -> ffi::GtkIMStatusStyle {
        match *self {
            IMStatusStyle::Nothing => ffi::GTK_IM_STATUS_NOTHING,
            IMStatusStyle::Callback => ffi::GTK_IM_STATUS_CALLBACK,
            IMStatusStyle::None => ffi::GTK_IM_STATUS_NONE,
            IMStatusStyle::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkIMStatusStyle> for IMStatusStyle {
    fn from_glib(value: ffi::GtkIMStatusStyle) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_IM_STATUS_NOTHING => IMStatusStyle::Nothing,
            ffi::GTK_IM_STATUS_CALLBACK => IMStatusStyle::Callback,
            ffi::GTK_IM_STATUS_NONE => IMStatusStyle::None,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum IconSize {
    Invalid,
    Menu,
    SmallToolbar,
    LargeToolbar,
    Button,
    Dnd,
    Dialog,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for IconSize {
    type GlibType = ffi::GtkIconSize;

    fn to_glib(&self) -> ffi::GtkIconSize {
        match *self {
            IconSize::Invalid => ffi::GTK_ICON_SIZE_INVALID,
            IconSize::Menu => ffi::GTK_ICON_SIZE_MENU,
            IconSize::SmallToolbar => ffi::GTK_ICON_SIZE_SMALL_TOOLBAR,
            IconSize::LargeToolbar => ffi::GTK_ICON_SIZE_LARGE_TOOLBAR,
            IconSize::Button => ffi::GTK_ICON_SIZE_BUTTON,
            IconSize::Dnd => ffi::GTK_ICON_SIZE_DND,
            IconSize::Dialog => ffi::GTK_ICON_SIZE_DIALOG,
            IconSize::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkIconSize> for IconSize {
    fn from_glib(value: ffi::GtkIconSize) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_ICON_SIZE_INVALID => IconSize::Invalid,
            ffi::GTK_ICON_SIZE_MENU => IconSize::Menu,
            ffi::GTK_ICON_SIZE_SMALL_TOOLBAR => IconSize::SmallToolbar,
            ffi::GTK_ICON_SIZE_LARGE_TOOLBAR => IconSize::LargeToolbar,
            ffi::GTK_ICON_SIZE_BUTTON => IconSize::Button,
            ffi::GTK_ICON_SIZE_DND => IconSize::Dnd,
            ffi::GTK_ICON_SIZE_DIALOG => IconSize::Dialog,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum IconThemeError {
    NotFound,
    Failed,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for IconThemeError {
    type GlibType = ffi::GtkIconThemeError;

    fn to_glib(&self) -> ffi::GtkIconThemeError {
        match *self {
            IconThemeError::NotFound => ffi::GTK_ICON_THEME_NOT_FOUND,
            IconThemeError::Failed => ffi::GTK_ICON_THEME_FAILED,
            IconThemeError::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkIconThemeError> for IconThemeError {
    fn from_glib(value: ffi::GtkIconThemeError) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_ICON_THEME_NOT_FOUND => IconThemeError::NotFound,
            ffi::GTK_ICON_THEME_FAILED => IconThemeError::Failed,
        }
    }
}

impl ErrorDomain for IconThemeError {
    fn domain() -> glib_ffi::GQuark {
        skip_assert_initialized!();
        unsafe { ffi::gtk_icon_theme_error_quark() }
    }

    fn code(self) -> i32 {
        self.to_glib() as i32
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            x if x == ffi::GTK_ICON_THEME_NOT_FOUND as i32 => Some(IconThemeError::NotFound),
            x if x == ffi::GTK_ICON_THEME_FAILED as i32 => Some(IconThemeError::Failed),
            _ => Some(IconThemeError::Failed),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum IconViewDropPosition {
    NoDrop,
    DropInto,
    DropLeft,
    DropRight,
    DropAbove,
    DropBelow,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for IconViewDropPosition {
    type GlibType = ffi::GtkIconViewDropPosition;

    fn to_glib(&self) -> ffi::GtkIconViewDropPosition {
        match *self {
            IconViewDropPosition::NoDrop => ffi::GTK_ICON_VIEW_NO_DROP,
            IconViewDropPosition::DropInto => ffi::GTK_ICON_VIEW_DROP_INTO,
            IconViewDropPosition::DropLeft => ffi::GTK_ICON_VIEW_DROP_LEFT,
            IconViewDropPosition::DropRight => ffi::GTK_ICON_VIEW_DROP_RIGHT,
            IconViewDropPosition::DropAbove => ffi::GTK_ICON_VIEW_DROP_ABOVE,
            IconViewDropPosition::DropBelow => ffi::GTK_ICON_VIEW_DROP_BELOW,
            IconViewDropPosition::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkIconViewDropPosition> for IconViewDropPosition {
    fn from_glib(value: ffi::GtkIconViewDropPosition) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_ICON_VIEW_NO_DROP => IconViewDropPosition::NoDrop,
            ffi::GTK_ICON_VIEW_DROP_INTO => IconViewDropPosition::DropInto,
            ffi::GTK_ICON_VIEW_DROP_LEFT => IconViewDropPosition::DropLeft,
            ffi::GTK_ICON_VIEW_DROP_RIGHT => IconViewDropPosition::DropRight,
            ffi::GTK_ICON_VIEW_DROP_ABOVE => IconViewDropPosition::DropAbove,
            ffi::GTK_ICON_VIEW_DROP_BELOW => IconViewDropPosition::DropBelow,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ImageType {
    Empty,
    Pixbuf,
    Stock,
    IconSet,
    Animation,
    IconName,
    Gicon,
    Surface,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for ImageType {
    type GlibType = ffi::GtkImageType;

    fn to_glib(&self) -> ffi::GtkImageType {
        match *self {
            ImageType::Empty => ffi::GTK_IMAGE_EMPTY,
            ImageType::Pixbuf => ffi::GTK_IMAGE_PIXBUF,
            ImageType::Stock => ffi::GTK_IMAGE_STOCK,
            ImageType::IconSet => ffi::GTK_IMAGE_ICON_SET,
            ImageType::Animation => ffi::GTK_IMAGE_ANIMATION,
            ImageType::IconName => ffi::GTK_IMAGE_ICON_NAME,
            ImageType::Gicon => ffi::GTK_IMAGE_GICON,
            ImageType::Surface => ffi::GTK_IMAGE_SURFACE,
            ImageType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkImageType> for ImageType {
    fn from_glib(value: ffi::GtkImageType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_IMAGE_EMPTY => ImageType::Empty,
            ffi::GTK_IMAGE_PIXBUF => ImageType::Pixbuf,
            ffi::GTK_IMAGE_STOCK => ImageType::Stock,
            ffi::GTK_IMAGE_ICON_SET => ImageType::IconSet,
            ffi::GTK_IMAGE_ANIMATION => ImageType::Animation,
            ffi::GTK_IMAGE_ICON_NAME => ImageType::IconName,
            ffi::GTK_IMAGE_GICON => ImageType::Gicon,
            ffi::GTK_IMAGE_SURFACE => ImageType::Surface,
        }
    }
}

#[cfg(feature = "v3_6")]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum InputPurpose {
    FreeForm,
    Alpha,
    Digits,
    Number,
    Phone,
    Url,
    Email,
    Name,
    Password,
    Pin,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[cfg(feature = "v3_6")]
#[doc(hidden)]
impl ToGlib for InputPurpose {
    type GlibType = ffi::GtkInputPurpose;

    fn to_glib(&self) -> ffi::GtkInputPurpose {
        match *self {
            InputPurpose::FreeForm => ffi::GTK_INPUT_PURPOSE_FREE_FORM,
            InputPurpose::Alpha => ffi::GTK_INPUT_PURPOSE_ALPHA,
            InputPurpose::Digits => ffi::GTK_INPUT_PURPOSE_DIGITS,
            InputPurpose::Number => ffi::GTK_INPUT_PURPOSE_NUMBER,
            InputPurpose::Phone => ffi::GTK_INPUT_PURPOSE_PHONE,
            InputPurpose::Url => ffi::GTK_INPUT_PURPOSE_URL,
            InputPurpose::Email => ffi::GTK_INPUT_PURPOSE_EMAIL,
            InputPurpose::Name => ffi::GTK_INPUT_PURPOSE_NAME,
            InputPurpose::Password => ffi::GTK_INPUT_PURPOSE_PASSWORD,
            InputPurpose::Pin => ffi::GTK_INPUT_PURPOSE_PIN,
            InputPurpose::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[cfg(feature = "v3_6")]
#[doc(hidden)]
impl FromGlib<ffi::GtkInputPurpose> for InputPurpose {
    fn from_glib(value: ffi::GtkInputPurpose) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_INPUT_PURPOSE_FREE_FORM => InputPurpose::FreeForm,
            ffi::GTK_INPUT_PURPOSE_ALPHA => InputPurpose::Alpha,
            ffi::GTK_INPUT_PURPOSE_DIGITS => InputPurpose::Digits,
            ffi::GTK_INPUT_PURPOSE_NUMBER => InputPurpose::Number,
            ffi::GTK_INPUT_PURPOSE_PHONE => InputPurpose::Phone,
            ffi::GTK_INPUT_PURPOSE_URL => InputPurpose::Url,
            ffi::GTK_INPUT_PURPOSE_EMAIL => InputPurpose::Email,
            ffi::GTK_INPUT_PURPOSE_NAME => InputPurpose::Name,
            ffi::GTK_INPUT_PURPOSE_PASSWORD => InputPurpose::Password,
            ffi::GTK_INPUT_PURPOSE_PIN => InputPurpose::Pin,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum Justification {
    Left,
    Right,
    Center,
    Fill,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for Justification {
    type GlibType = ffi::GtkJustification;

    fn to_glib(&self) -> ffi::GtkJustification {
        match *self {
            Justification::Left => ffi::GTK_JUSTIFY_LEFT,
            Justification::Right => ffi::GTK_JUSTIFY_RIGHT,
            Justification::Center => ffi::GTK_JUSTIFY_CENTER,
            Justification::Fill => ffi::GTK_JUSTIFY_FILL,
            Justification::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkJustification> for Justification {
    fn from_glib(value: ffi::GtkJustification) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_JUSTIFY_LEFT => Justification::Left,
            ffi::GTK_JUSTIFY_RIGHT => Justification::Right,
            ffi::GTK_JUSTIFY_CENTER => Justification::Center,
            ffi::GTK_JUSTIFY_FILL => Justification::Fill,
        }
    }
}

#[cfg(feature = "v3_6")]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum LevelBarMode {
    Continuous,
    Discrete,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[cfg(feature = "v3_6")]
#[doc(hidden)]
impl ToGlib for LevelBarMode {
    type GlibType = ffi::GtkLevelBarMode;

    fn to_glib(&self) -> ffi::GtkLevelBarMode {
        match *self {
            LevelBarMode::Continuous => ffi::GTK_LEVEL_BAR_MODE_CONTINUOUS,
            LevelBarMode::Discrete => ffi::GTK_LEVEL_BAR_MODE_DISCRETE,
            LevelBarMode::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[cfg(feature = "v3_6")]
#[doc(hidden)]
impl FromGlib<ffi::GtkLevelBarMode> for LevelBarMode {
    fn from_glib(value: ffi::GtkLevelBarMode) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_LEVEL_BAR_MODE_CONTINUOUS => LevelBarMode::Continuous,
            ffi::GTK_LEVEL_BAR_MODE_DISCRETE => LevelBarMode::Discrete,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum License {
    Unknown,
    Custom,
    Gpl20,
    Gpl30,
    Lgpl21,
    Lgpl30,
    Bsd,
    MitX11,
    Artistic,
    Gpl20Only,
    Gpl30Only,
    Lgpl21Only,
    Lgpl30Only,
    Agpl30,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for License {
    type GlibType = ffi::GtkLicense;

    fn to_glib(&self) -> ffi::GtkLicense {
        match *self {
            License::Unknown => ffi::GTK_LICENSE_UNKNOWN,
            License::Custom => ffi::GTK_LICENSE_CUSTOM,
            License::Gpl20 => ffi::GTK_LICENSE_GPL_2_0,
            License::Gpl30 => ffi::GTK_LICENSE_GPL_3_0,
            License::Lgpl21 => ffi::GTK_LICENSE_LGPL_2_1,
            License::Lgpl30 => ffi::GTK_LICENSE_LGPL_3_0,
            License::Bsd => ffi::GTK_LICENSE_BSD,
            License::MitX11 => ffi::GTK_LICENSE_MIT_X11,
            License::Artistic => ffi::GTK_LICENSE_ARTISTIC,
            License::Gpl20Only => ffi::GTK_LICENSE_GPL_2_0_ONLY,
            License::Gpl30Only => ffi::GTK_LICENSE_GPL_3_0_ONLY,
            License::Lgpl21Only => ffi::GTK_LICENSE_LGPL_2_1_ONLY,
            License::Lgpl30Only => ffi::GTK_LICENSE_LGPL_3_0_ONLY,
            License::Agpl30 => ffi::GTK_LICENSE_AGPL_3_0,
            License::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkLicense> for License {
    fn from_glib(value: ffi::GtkLicense) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_LICENSE_UNKNOWN => License::Unknown,
            ffi::GTK_LICENSE_CUSTOM => License::Custom,
            ffi::GTK_LICENSE_GPL_2_0 => License::Gpl20,
            ffi::GTK_LICENSE_GPL_3_0 => License::Gpl30,
            ffi::GTK_LICENSE_LGPL_2_1 => License::Lgpl21,
            ffi::GTK_LICENSE_LGPL_3_0 => License::Lgpl30,
            ffi::GTK_LICENSE_BSD => License::Bsd,
            ffi::GTK_LICENSE_MIT_X11 => License::MitX11,
            ffi::GTK_LICENSE_ARTISTIC => License::Artistic,
            ffi::GTK_LICENSE_GPL_2_0_ONLY => License::Gpl20Only,
            ffi::GTK_LICENSE_GPL_3_0_ONLY => License::Gpl30Only,
            ffi::GTK_LICENSE_LGPL_2_1_ONLY => License::Lgpl21Only,
            ffi::GTK_LICENSE_LGPL_3_0_ONLY => License::Lgpl30Only,
            ffi::GTK_LICENSE_AGPL_3_0 => License::Agpl30,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum MenuDirectionType {
    Parent,
    Child,
    Next,
    Prev,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for MenuDirectionType {
    type GlibType = ffi::GtkMenuDirectionType;

    fn to_glib(&self) -> ffi::GtkMenuDirectionType {
        match *self {
            MenuDirectionType::Parent => ffi::GTK_MENU_DIR_PARENT,
            MenuDirectionType::Child => ffi::GTK_MENU_DIR_CHILD,
            MenuDirectionType::Next => ffi::GTK_MENU_DIR_NEXT,
            MenuDirectionType::Prev => ffi::GTK_MENU_DIR_PREV,
            MenuDirectionType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkMenuDirectionType> for MenuDirectionType {
    fn from_glib(value: ffi::GtkMenuDirectionType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_MENU_DIR_PARENT => MenuDirectionType::Parent,
            ffi::GTK_MENU_DIR_CHILD => MenuDirectionType::Child,
            ffi::GTK_MENU_DIR_NEXT => MenuDirectionType::Next,
            ffi::GTK_MENU_DIR_PREV => MenuDirectionType::Prev,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum MessageType {
    Info,
    Warning,
    Question,
    Error,
    Other,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for MessageType {
    type GlibType = ffi::GtkMessageType;

    fn to_glib(&self) -> ffi::GtkMessageType {
        match *self {
            MessageType::Info => ffi::GTK_MESSAGE_INFO,
            MessageType::Warning => ffi::GTK_MESSAGE_WARNING,
            MessageType::Question => ffi::GTK_MESSAGE_QUESTION,
            MessageType::Error => ffi::GTK_MESSAGE_ERROR,
            MessageType::Other => ffi::GTK_MESSAGE_OTHER,
            MessageType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkMessageType> for MessageType {
    fn from_glib(value: ffi::GtkMessageType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_MESSAGE_INFO => MessageType::Info,
            ffi::GTK_MESSAGE_WARNING => MessageType::Warning,
            ffi::GTK_MESSAGE_QUESTION => MessageType::Question,
            ffi::GTK_MESSAGE_ERROR => MessageType::Error,
            ffi::GTK_MESSAGE_OTHER => MessageType::Other,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum MovementStep {
    LogicalPositions,
    VisualPositions,
    Words,
    DisplayLines,
    DisplayLineEnds,
    Paragraphs,
    ParagraphEnds,
    Pages,
    BufferEnds,
    HorizontalPages,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for MovementStep {
    type GlibType = ffi::GtkMovementStep;

    fn to_glib(&self) -> ffi::GtkMovementStep {
        match *self {
            MovementStep::LogicalPositions => ffi::GTK_MOVEMENT_LOGICAL_POSITIONS,
            MovementStep::VisualPositions => ffi::GTK_MOVEMENT_VISUAL_POSITIONS,
            MovementStep::Words => ffi::GTK_MOVEMENT_WORDS,
            MovementStep::DisplayLines => ffi::GTK_MOVEMENT_DISPLAY_LINES,
            MovementStep::DisplayLineEnds => ffi::GTK_MOVEMENT_DISPLAY_LINE_ENDS,
            MovementStep::Paragraphs => ffi::GTK_MOVEMENT_PARAGRAPHS,
            MovementStep::ParagraphEnds => ffi::GTK_MOVEMENT_PARAGRAPH_ENDS,
            MovementStep::Pages => ffi::GTK_MOVEMENT_PAGES,
            MovementStep::BufferEnds => ffi::GTK_MOVEMENT_BUFFER_ENDS,
            MovementStep::HorizontalPages => ffi::GTK_MOVEMENT_HORIZONTAL_PAGES,
            MovementStep::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkMovementStep> for MovementStep {
    fn from_glib(value: ffi::GtkMovementStep) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_MOVEMENT_LOGICAL_POSITIONS => MovementStep::LogicalPositions,
            ffi::GTK_MOVEMENT_VISUAL_POSITIONS => MovementStep::VisualPositions,
            ffi::GTK_MOVEMENT_WORDS => MovementStep::Words,
            ffi::GTK_MOVEMENT_DISPLAY_LINES => MovementStep::DisplayLines,
            ffi::GTK_MOVEMENT_DISPLAY_LINE_ENDS => MovementStep::DisplayLineEnds,
            ffi::GTK_MOVEMENT_PARAGRAPHS => MovementStep::Paragraphs,
            ffi::GTK_MOVEMENT_PARAGRAPH_ENDS => MovementStep::ParagraphEnds,
            ffi::GTK_MOVEMENT_PAGES => MovementStep::Pages,
            ffi::GTK_MOVEMENT_BUFFER_ENDS => MovementStep::BufferEnds,
            ffi::GTK_MOVEMENT_HORIZONTAL_PAGES => MovementStep::HorizontalPages,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum NotebookTab {
    First,
    Last,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for NotebookTab {
    type GlibType = ffi::GtkNotebookTab;

    fn to_glib(&self) -> ffi::GtkNotebookTab {
        match *self {
            NotebookTab::First => ffi::GTK_NOTEBOOK_TAB_FIRST,
            NotebookTab::Last => ffi::GTK_NOTEBOOK_TAB_LAST,
            NotebookTab::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkNotebookTab> for NotebookTab {
    fn from_glib(value: ffi::GtkNotebookTab) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_NOTEBOOK_TAB_FIRST => NotebookTab::First,
            ffi::GTK_NOTEBOOK_TAB_LAST => NotebookTab::Last,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum NumberUpLayout {
    Lrtb,
    Lrbt,
    Rltb,
    Rlbt,
    Tblr,
    Tbrl,
    Btlr,
    Btrl,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for NumberUpLayout {
    type GlibType = ffi::GtkNumberUpLayout;

    fn to_glib(&self) -> ffi::GtkNumberUpLayout {
        match *self {
            NumberUpLayout::Lrtb => ffi::GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_TOP_TO_BOTTOM,
            NumberUpLayout::Lrbt => ffi::GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_BOTTOM_TO_TOP,
            NumberUpLayout::Rltb => ffi::GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_TOP_TO_BOTTOM,
            NumberUpLayout::Rlbt => ffi::GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_BOTTOM_TO_TOP,
            NumberUpLayout::Tblr => ffi::GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_LEFT_TO_RIGHT,
            NumberUpLayout::Tbrl => ffi::GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_RIGHT_TO_LEFT,
            NumberUpLayout::Btlr => ffi::GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_LEFT_TO_RIGHT,
            NumberUpLayout::Btrl => ffi::GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_RIGHT_TO_LEFT,
            NumberUpLayout::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkNumberUpLayout> for NumberUpLayout {
    fn from_glib(value: ffi::GtkNumberUpLayout) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_TOP_TO_BOTTOM => NumberUpLayout::Lrtb,
            ffi::GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_BOTTOM_TO_TOP => NumberUpLayout::Lrbt,
            ffi::GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_TOP_TO_BOTTOM => NumberUpLayout::Rltb,
            ffi::GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_BOTTOM_TO_TOP => NumberUpLayout::Rlbt,
            ffi::GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_LEFT_TO_RIGHT => NumberUpLayout::Tblr,
            ffi::GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_RIGHT_TO_LEFT => NumberUpLayout::Tbrl,
            ffi::GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_LEFT_TO_RIGHT => NumberUpLayout::Btlr,
            ffi::GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_RIGHT_TO_LEFT => NumberUpLayout::Btrl,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum Orientation {
    Horizontal,
    Vertical,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for Orientation {
    type GlibType = ffi::GtkOrientation;

    fn to_glib(&self) -> ffi::GtkOrientation {
        match *self {
            Orientation::Horizontal => ffi::GTK_ORIENTATION_HORIZONTAL,
            Orientation::Vertical => ffi::GTK_ORIENTATION_VERTICAL,
            Orientation::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkOrientation> for Orientation {
    fn from_glib(value: ffi::GtkOrientation) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_ORIENTATION_HORIZONTAL => Orientation::Horizontal,
            ffi::GTK_ORIENTATION_VERTICAL => Orientation::Vertical,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PackDirection {
    Ltr,
    Rtl,
    Ttb,
    Btt,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for PackDirection {
    type GlibType = ffi::GtkPackDirection;

    fn to_glib(&self) -> ffi::GtkPackDirection {
        match *self {
            PackDirection::Ltr => ffi::GTK_PACK_DIRECTION_LTR,
            PackDirection::Rtl => ffi::GTK_PACK_DIRECTION_RTL,
            PackDirection::Ttb => ffi::GTK_PACK_DIRECTION_TTB,
            PackDirection::Btt => ffi::GTK_PACK_DIRECTION_BTT,
            PackDirection::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPackDirection> for PackDirection {
    fn from_glib(value: ffi::GtkPackDirection) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_PACK_DIRECTION_LTR => PackDirection::Ltr,
            ffi::GTK_PACK_DIRECTION_RTL => PackDirection::Rtl,
            ffi::GTK_PACK_DIRECTION_TTB => PackDirection::Ttb,
            ffi::GTK_PACK_DIRECTION_BTT => PackDirection::Btt,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PackType {
    Start,
    End,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for PackType {
    type GlibType = ffi::GtkPackType;

    fn to_glib(&self) -> ffi::GtkPackType {
        match *self {
            PackType::Start => ffi::GTK_PACK_START,
            PackType::End => ffi::GTK_PACK_END,
            PackType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPackType> for PackType {
    fn from_glib(value: ffi::GtkPackType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_PACK_START => PackType::Start,
            ffi::GTK_PACK_END => PackType::End,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PageOrientation {
    Portrait,
    Landscape,
    ReversePortrait,
    ReverseLandscape,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for PageOrientation {
    type GlibType = ffi::GtkPageOrientation;

    fn to_glib(&self) -> ffi::GtkPageOrientation {
        match *self {
            PageOrientation::Portrait => ffi::GTK_PAGE_ORIENTATION_PORTRAIT,
            PageOrientation::Landscape => ffi::GTK_PAGE_ORIENTATION_LANDSCAPE,
            PageOrientation::ReversePortrait => ffi::GTK_PAGE_ORIENTATION_REVERSE_PORTRAIT,
            PageOrientation::ReverseLandscape => ffi::GTK_PAGE_ORIENTATION_REVERSE_LANDSCAPE,
            PageOrientation::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPageOrientation> for PageOrientation {
    fn from_glib(value: ffi::GtkPageOrientation) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_PAGE_ORIENTATION_PORTRAIT => PageOrientation::Portrait,
            ffi::GTK_PAGE_ORIENTATION_LANDSCAPE => PageOrientation::Landscape,
            ffi::GTK_PAGE_ORIENTATION_REVERSE_PORTRAIT => PageOrientation::ReversePortrait,
            ffi::GTK_PAGE_ORIENTATION_REVERSE_LANDSCAPE => PageOrientation::ReverseLandscape,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PageSet {
    All,
    Even,
    Odd,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for PageSet {
    type GlibType = ffi::GtkPageSet;

    fn to_glib(&self) -> ffi::GtkPageSet {
        match *self {
            PageSet::All => ffi::GTK_PAGE_SET_ALL,
            PageSet::Even => ffi::GTK_PAGE_SET_EVEN,
            PageSet::Odd => ffi::GTK_PAGE_SET_ODD,
            PageSet::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPageSet> for PageSet {
    fn from_glib(value: ffi::GtkPageSet) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_PAGE_SET_ALL => PageSet::All,
            ffi::GTK_PAGE_SET_EVEN => PageSet::Even,
            ffi::GTK_PAGE_SET_ODD => PageSet::Odd,
        }
    }
}

#[cfg(feature = "v3_14")]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PanDirection {
    Left,
    Right,
    Up,
    Down,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[cfg(feature = "v3_14")]
#[doc(hidden)]
impl ToGlib for PanDirection {
    type GlibType = ffi::GtkPanDirection;

    fn to_glib(&self) -> ffi::GtkPanDirection {
        match *self {
            PanDirection::Left => ffi::GTK_PAN_DIRECTION_LEFT,
            PanDirection::Right => ffi::GTK_PAN_DIRECTION_RIGHT,
            PanDirection::Up => ffi::GTK_PAN_DIRECTION_UP,
            PanDirection::Down => ffi::GTK_PAN_DIRECTION_DOWN,
            PanDirection::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[cfg(feature = "v3_14")]
#[doc(hidden)]
impl FromGlib<ffi::GtkPanDirection> for PanDirection {
    fn from_glib(value: ffi::GtkPanDirection) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_PAN_DIRECTION_LEFT => PanDirection::Left,
            ffi::GTK_PAN_DIRECTION_RIGHT => PanDirection::Right,
            ffi::GTK_PAN_DIRECTION_UP => PanDirection::Up,
            ffi::GTK_PAN_DIRECTION_DOWN => PanDirection::Down,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PolicyType {
    Always,
    Automatic,
    Never,
    External,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for PolicyType {
    type GlibType = ffi::GtkPolicyType;

    fn to_glib(&self) -> ffi::GtkPolicyType {
        match *self {
            PolicyType::Always => ffi::GTK_POLICY_ALWAYS,
            PolicyType::Automatic => ffi::GTK_POLICY_AUTOMATIC,
            PolicyType::Never => ffi::GTK_POLICY_NEVER,
            PolicyType::External => ffi::GTK_POLICY_EXTERNAL,
            PolicyType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPolicyType> for PolicyType {
    fn from_glib(value: ffi::GtkPolicyType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_POLICY_ALWAYS => PolicyType::Always,
            ffi::GTK_POLICY_AUTOMATIC => PolicyType::Automatic,
            ffi::GTK_POLICY_NEVER => PolicyType::Never,
            ffi::GTK_POLICY_EXTERNAL => PolicyType::External,
        }
    }
}

#[cfg(feature = "v3_20")]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PopoverConstraint {
    None,
    Window,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[cfg(feature = "v3_20")]
#[doc(hidden)]
impl ToGlib for PopoverConstraint {
    type GlibType = ffi::GtkPopoverConstraint;

    fn to_glib(&self) -> ffi::GtkPopoverConstraint {
        match *self {
            PopoverConstraint::None => ffi::GTK_POPOVER_CONSTRAINT_NONE,
            PopoverConstraint::Window => ffi::GTK_POPOVER_CONSTRAINT_WINDOW,
            PopoverConstraint::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[cfg(feature = "v3_20")]
#[doc(hidden)]
impl FromGlib<ffi::GtkPopoverConstraint> for PopoverConstraint {
    fn from_glib(value: ffi::GtkPopoverConstraint) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_POPOVER_CONSTRAINT_NONE => PopoverConstraint::None,
            ffi::GTK_POPOVER_CONSTRAINT_WINDOW => PopoverConstraint::Window,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PositionType {
    Left,
    Right,
    Top,
    Bottom,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for PositionType {
    type GlibType = ffi::GtkPositionType;

    fn to_glib(&self) -> ffi::GtkPositionType {
        match *self {
            PositionType::Left => ffi::GTK_POS_LEFT,
            PositionType::Right => ffi::GTK_POS_RIGHT,
            PositionType::Top => ffi::GTK_POS_TOP,
            PositionType::Bottom => ffi::GTK_POS_BOTTOM,
            PositionType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPositionType> for PositionType {
    fn from_glib(value: ffi::GtkPositionType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_POS_LEFT => PositionType::Left,
            ffi::GTK_POS_RIGHT => PositionType::Right,
            ffi::GTK_POS_TOP => PositionType::Top,
            ffi::GTK_POS_BOTTOM => PositionType::Bottom,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PrintDuplex {
    Simplex,
    Horizontal,
    Vertical,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for PrintDuplex {
    type GlibType = ffi::GtkPrintDuplex;

    fn to_glib(&self) -> ffi::GtkPrintDuplex {
        match *self {
            PrintDuplex::Simplex => ffi::GTK_PRINT_DUPLEX_SIMPLEX,
            PrintDuplex::Horizontal => ffi::GTK_PRINT_DUPLEX_HORIZONTAL,
            PrintDuplex::Vertical => ffi::GTK_PRINT_DUPLEX_VERTICAL,
            PrintDuplex::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintDuplex> for PrintDuplex {
    fn from_glib(value: ffi::GtkPrintDuplex) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_PRINT_DUPLEX_SIMPLEX => PrintDuplex::Simplex,
            ffi::GTK_PRINT_DUPLEX_HORIZONTAL => PrintDuplex::Horizontal,
            ffi::GTK_PRINT_DUPLEX_VERTICAL => PrintDuplex::Vertical,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PrintError {
    General,
    InternalError,
    Nomem,
    InvalidFile,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for PrintError {
    type GlibType = ffi::GtkPrintError;

    fn to_glib(&self) -> ffi::GtkPrintError {
        match *self {
            PrintError::General => ffi::GTK_PRINT_ERROR_GENERAL,
            PrintError::InternalError => ffi::GTK_PRINT_ERROR_INTERNAL_ERROR,
            PrintError::Nomem => ffi::GTK_PRINT_ERROR_NOMEM,
            PrintError::InvalidFile => ffi::GTK_PRINT_ERROR_INVALID_FILE,
            PrintError::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintError> for PrintError {
    fn from_glib(value: ffi::GtkPrintError) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_PRINT_ERROR_GENERAL => PrintError::General,
            ffi::GTK_PRINT_ERROR_INTERNAL_ERROR => PrintError::InternalError,
            ffi::GTK_PRINT_ERROR_NOMEM => PrintError::Nomem,
            ffi::GTK_PRINT_ERROR_INVALID_FILE => PrintError::InvalidFile,
        }
    }
}

impl ErrorDomain for PrintError {
    fn domain() -> glib_ffi::GQuark {
        skip_assert_initialized!();
        unsafe { ffi::gtk_print_error_quark() }
    }

    fn code(self) -> i32 {
        self.to_glib() as i32
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            x if x == ffi::GTK_PRINT_ERROR_GENERAL as i32 => Some(PrintError::General),
            x if x == ffi::GTK_PRINT_ERROR_INTERNAL_ERROR as i32 => Some(PrintError::InternalError),
            x if x == ffi::GTK_PRINT_ERROR_NOMEM as i32 => Some(PrintError::Nomem),
            x if x == ffi::GTK_PRINT_ERROR_INVALID_FILE as i32 => Some(PrintError::InvalidFile),
            _ => Some(PrintError::__Nonexhaustive(())),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PrintPages {
    All,
    Current,
    Ranges,
    Selection,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for PrintPages {
    type GlibType = ffi::GtkPrintPages;

    fn to_glib(&self) -> ffi::GtkPrintPages {
        match *self {
            PrintPages::All => ffi::GTK_PRINT_PAGES_ALL,
            PrintPages::Current => ffi::GTK_PRINT_PAGES_CURRENT,
            PrintPages::Ranges => ffi::GTK_PRINT_PAGES_RANGES,
            PrintPages::Selection => ffi::GTK_PRINT_PAGES_SELECTION,
            PrintPages::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintPages> for PrintPages {
    fn from_glib(value: ffi::GtkPrintPages) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_PRINT_PAGES_ALL => PrintPages::All,
            ffi::GTK_PRINT_PAGES_CURRENT => PrintPages::Current,
            ffi::GTK_PRINT_PAGES_RANGES => PrintPages::Ranges,
            ffi::GTK_PRINT_PAGES_SELECTION => PrintPages::Selection,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PrintQuality {
    Low,
    Normal,
    High,
    Draft,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for PrintQuality {
    type GlibType = ffi::GtkPrintQuality;

    fn to_glib(&self) -> ffi::GtkPrintQuality {
        match *self {
            PrintQuality::Low => ffi::GTK_PRINT_QUALITY_LOW,
            PrintQuality::Normal => ffi::GTK_PRINT_QUALITY_NORMAL,
            PrintQuality::High => ffi::GTK_PRINT_QUALITY_HIGH,
            PrintQuality::Draft => ffi::GTK_PRINT_QUALITY_DRAFT,
            PrintQuality::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkPrintQuality> for PrintQuality {
    fn from_glib(value: ffi::GtkPrintQuality) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_PRINT_QUALITY_LOW => PrintQuality::Low,
            ffi::GTK_PRINT_QUALITY_NORMAL => PrintQuality::Normal,
            ffi::GTK_PRINT_QUALITY_HIGH => PrintQuality::High,
            ffi::GTK_PRINT_QUALITY_DRAFT => PrintQuality::Draft,
        }
    }
}

#[cfg(feature = "v3_14")]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PropagationPhase {
    None,
    Capture,
    Bubble,
    Target,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[cfg(feature = "v3_14")]
#[doc(hidden)]
impl ToGlib for PropagationPhase {
    type GlibType = ffi::GtkPropagationPhase;

    fn to_glib(&self) -> ffi::GtkPropagationPhase {
        match *self {
            PropagationPhase::None => ffi::GTK_PHASE_NONE,
            PropagationPhase::Capture => ffi::GTK_PHASE_CAPTURE,
            PropagationPhase::Bubble => ffi::GTK_PHASE_BUBBLE,
            PropagationPhase::Target => ffi::GTK_PHASE_TARGET,
            PropagationPhase::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[cfg(feature = "v3_14")]
#[doc(hidden)]
impl FromGlib<ffi::GtkPropagationPhase> for PropagationPhase {
    fn from_glib(value: ffi::GtkPropagationPhase) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_PHASE_NONE => PropagationPhase::None,
            ffi::GTK_PHASE_CAPTURE => PropagationPhase::Capture,
            ffi::GTK_PHASE_BUBBLE => PropagationPhase::Bubble,
            ffi::GTK_PHASE_TARGET => PropagationPhase::Target,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum RecentChooserError {
    NotFound,
    InvalidUri,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for RecentChooserError {
    type GlibType = ffi::GtkRecentChooserError;

    fn to_glib(&self) -> ffi::GtkRecentChooserError {
        match *self {
            RecentChooserError::NotFound => ffi::GTK_RECENT_CHOOSER_ERROR_NOT_FOUND,
            RecentChooserError::InvalidUri => ffi::GTK_RECENT_CHOOSER_ERROR_INVALID_URI,
            RecentChooserError::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkRecentChooserError> for RecentChooserError {
    fn from_glib(value: ffi::GtkRecentChooserError) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_RECENT_CHOOSER_ERROR_NOT_FOUND => RecentChooserError::NotFound,
            ffi::GTK_RECENT_CHOOSER_ERROR_INVALID_URI => RecentChooserError::InvalidUri,
        }
    }
}

impl ErrorDomain for RecentChooserError {
    fn domain() -> glib_ffi::GQuark {
        skip_assert_initialized!();
        unsafe { ffi::gtk_recent_chooser_error_quark() }
    }

    fn code(self) -> i32 {
        self.to_glib() as i32
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            x if x == ffi::GTK_RECENT_CHOOSER_ERROR_NOT_FOUND as i32 => Some(RecentChooserError::NotFound),
            x if x == ffi::GTK_RECENT_CHOOSER_ERROR_INVALID_URI as i32 => Some(RecentChooserError::InvalidUri),
            _ => Some(RecentChooserError::__Nonexhaustive(())),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum RecentManagerError {
    NotFound,
    InvalidUri,
    InvalidEncoding,
    NotRegistered,
    Read,
    Write,
    Unknown,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for RecentManagerError {
    type GlibType = ffi::GtkRecentManagerError;

    fn to_glib(&self) -> ffi::GtkRecentManagerError {
        match *self {
            RecentManagerError::NotFound => ffi::GTK_RECENT_MANAGER_ERROR_NOT_FOUND,
            RecentManagerError::InvalidUri => ffi::GTK_RECENT_MANAGER_ERROR_INVALID_URI,
            RecentManagerError::InvalidEncoding => ffi::GTK_RECENT_MANAGER_ERROR_INVALID_ENCODING,
            RecentManagerError::NotRegistered => ffi::GTK_RECENT_MANAGER_ERROR_NOT_REGISTERED,
            RecentManagerError::Read => ffi::GTK_RECENT_MANAGER_ERROR_READ,
            RecentManagerError::Write => ffi::GTK_RECENT_MANAGER_ERROR_WRITE,
            RecentManagerError::Unknown => ffi::GTK_RECENT_MANAGER_ERROR_UNKNOWN,
            RecentManagerError::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkRecentManagerError> for RecentManagerError {
    fn from_glib(value: ffi::GtkRecentManagerError) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_RECENT_MANAGER_ERROR_NOT_FOUND => RecentManagerError::NotFound,
            ffi::GTK_RECENT_MANAGER_ERROR_INVALID_URI => RecentManagerError::InvalidUri,
            ffi::GTK_RECENT_MANAGER_ERROR_INVALID_ENCODING => RecentManagerError::InvalidEncoding,
            ffi::GTK_RECENT_MANAGER_ERROR_NOT_REGISTERED => RecentManagerError::NotRegistered,
            ffi::GTK_RECENT_MANAGER_ERROR_READ => RecentManagerError::Read,
            ffi::GTK_RECENT_MANAGER_ERROR_WRITE => RecentManagerError::Write,
            ffi::GTK_RECENT_MANAGER_ERROR_UNKNOWN => RecentManagerError::Unknown,
        }
    }
}

impl ErrorDomain for RecentManagerError {
    fn domain() -> glib_ffi::GQuark {
        skip_assert_initialized!();
        unsafe { ffi::gtk_recent_manager_error_quark() }
    }

    fn code(self) -> i32 {
        self.to_glib() as i32
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            x if x == ffi::GTK_RECENT_MANAGER_ERROR_NOT_FOUND as i32 => Some(RecentManagerError::NotFound),
            x if x == ffi::GTK_RECENT_MANAGER_ERROR_INVALID_URI as i32 => Some(RecentManagerError::InvalidUri),
            x if x == ffi::GTK_RECENT_MANAGER_ERROR_INVALID_ENCODING as i32 => Some(RecentManagerError::InvalidEncoding),
            x if x == ffi::GTK_RECENT_MANAGER_ERROR_NOT_REGISTERED as i32 => Some(RecentManagerError::NotRegistered),
            x if x == ffi::GTK_RECENT_MANAGER_ERROR_READ as i32 => Some(RecentManagerError::Read),
            x if x == ffi::GTK_RECENT_MANAGER_ERROR_WRITE as i32 => Some(RecentManagerError::Write),
            x if x == ffi::GTK_RECENT_MANAGER_ERROR_UNKNOWN as i32 => Some(RecentManagerError::Unknown),
            _ => Some(RecentManagerError::__Nonexhaustive(())),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum RecentSortType {
    None,
    Mru,
    Lru,
    Custom,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for RecentSortType {
    type GlibType = ffi::GtkRecentSortType;

    fn to_glib(&self) -> ffi::GtkRecentSortType {
        match *self {
            RecentSortType::None => ffi::GTK_RECENT_SORT_NONE,
            RecentSortType::Mru => ffi::GTK_RECENT_SORT_MRU,
            RecentSortType::Lru => ffi::GTK_RECENT_SORT_LRU,
            RecentSortType::Custom => ffi::GTK_RECENT_SORT_CUSTOM,
            RecentSortType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkRecentSortType> for RecentSortType {
    fn from_glib(value: ffi::GtkRecentSortType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_RECENT_SORT_NONE => RecentSortType::None,
            ffi::GTK_RECENT_SORT_MRU => RecentSortType::Mru,
            ffi::GTK_RECENT_SORT_LRU => RecentSortType::Lru,
            ffi::GTK_RECENT_SORT_CUSTOM => RecentSortType::Custom,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ReliefStyle {
    Normal,
    Half,
    None,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for ReliefStyle {
    type GlibType = ffi::GtkReliefStyle;

    fn to_glib(&self) -> ffi::GtkReliefStyle {
        match *self {
            ReliefStyle::Normal => ffi::GTK_RELIEF_NORMAL,
            ReliefStyle::Half => ffi::GTK_RELIEF_HALF,
            ReliefStyle::None => ffi::GTK_RELIEF_NONE,
            ReliefStyle::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkReliefStyle> for ReliefStyle {
    fn from_glib(value: ffi::GtkReliefStyle) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_RELIEF_NORMAL => ReliefStyle::Normal,
            ffi::GTK_RELIEF_HALF => ReliefStyle::Half,
            ffi::GTK_RELIEF_NONE => ReliefStyle::None,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ResizeMode {
    Parent,
    Queue,
    Immediate,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for ResizeMode {
    type GlibType = ffi::GtkResizeMode;

    fn to_glib(&self) -> ffi::GtkResizeMode {
        match *self {
            ResizeMode::Parent => ffi::GTK_RESIZE_PARENT,
            ResizeMode::Queue => ffi::GTK_RESIZE_QUEUE,
            ResizeMode::Immediate => ffi::GTK_RESIZE_IMMEDIATE,
            ResizeMode::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkResizeMode> for ResizeMode {
    fn from_glib(value: ffi::GtkResizeMode) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_RESIZE_PARENT => ResizeMode::Parent,
            ffi::GTK_RESIZE_QUEUE => ResizeMode::Queue,
            ffi::GTK_RESIZE_IMMEDIATE => ResizeMode::Immediate,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ResponseType {
    None,
    Reject,
    Accept,
    DeleteEvent,
    Ok,
    Cancel,
    Close,
    Yes,
    No,
    Apply,
    Help,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for ResponseType {
    type GlibType = ffi::GtkResponseType;

    fn to_glib(&self) -> ffi::GtkResponseType {
        match *self {
            ResponseType::None => ffi::GTK_RESPONSE_NONE,
            ResponseType::Reject => ffi::GTK_RESPONSE_REJECT,
            ResponseType::Accept => ffi::GTK_RESPONSE_ACCEPT,
            ResponseType::DeleteEvent => ffi::GTK_RESPONSE_DELETE_EVENT,
            ResponseType::Ok => ffi::GTK_RESPONSE_OK,
            ResponseType::Cancel => ffi::GTK_RESPONSE_CANCEL,
            ResponseType::Close => ffi::GTK_RESPONSE_CLOSE,
            ResponseType::Yes => ffi::GTK_RESPONSE_YES,
            ResponseType::No => ffi::GTK_RESPONSE_NO,
            ResponseType::Apply => ffi::GTK_RESPONSE_APPLY,
            ResponseType::Help => ffi::GTK_RESPONSE_HELP,
            ResponseType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkResponseType> for ResponseType {
    fn from_glib(value: ffi::GtkResponseType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_RESPONSE_NONE => ResponseType::None,
            ffi::GTK_RESPONSE_REJECT => ResponseType::Reject,
            ffi::GTK_RESPONSE_ACCEPT => ResponseType::Accept,
            ffi::GTK_RESPONSE_DELETE_EVENT => ResponseType::DeleteEvent,
            ffi::GTK_RESPONSE_OK => ResponseType::Ok,
            ffi::GTK_RESPONSE_CANCEL => ResponseType::Cancel,
            ffi::GTK_RESPONSE_CLOSE => ResponseType::Close,
            ffi::GTK_RESPONSE_YES => ResponseType::Yes,
            ffi::GTK_RESPONSE_NO => ResponseType::No,
            ffi::GTK_RESPONSE_APPLY => ResponseType::Apply,
            ffi::GTK_RESPONSE_HELP => ResponseType::Help,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum RevealerTransitionType {
    None,
    Crossfade,
    SlideRight,
    SlideLeft,
    SlideUp,
    SlideDown,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for RevealerTransitionType {
    type GlibType = ffi::GtkRevealerTransitionType;

    fn to_glib(&self) -> ffi::GtkRevealerTransitionType {
        match *self {
            RevealerTransitionType::None => ffi::GTK_REVEALER_TRANSITION_TYPE_NONE,
            RevealerTransitionType::Crossfade => ffi::GTK_REVEALER_TRANSITION_TYPE_CROSSFADE,
            RevealerTransitionType::SlideRight => ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_RIGHT,
            RevealerTransitionType::SlideLeft => ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_LEFT,
            RevealerTransitionType::SlideUp => ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_UP,
            RevealerTransitionType::SlideDown => ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_DOWN,
            RevealerTransitionType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkRevealerTransitionType> for RevealerTransitionType {
    fn from_glib(value: ffi::GtkRevealerTransitionType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_REVEALER_TRANSITION_TYPE_NONE => RevealerTransitionType::None,
            ffi::GTK_REVEALER_TRANSITION_TYPE_CROSSFADE => RevealerTransitionType::Crossfade,
            ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_RIGHT => RevealerTransitionType::SlideRight,
            ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_LEFT => RevealerTransitionType::SlideLeft,
            ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_UP => RevealerTransitionType::SlideUp,
            ffi::GTK_REVEALER_TRANSITION_TYPE_SLIDE_DOWN => RevealerTransitionType::SlideDown,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ScrollStep {
    Steps,
    Pages,
    Ends,
    HorizontalSteps,
    HorizontalPages,
    HorizontalEnds,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for ScrollStep {
    type GlibType = ffi::GtkScrollStep;

    fn to_glib(&self) -> ffi::GtkScrollStep {
        match *self {
            ScrollStep::Steps => ffi::GTK_SCROLL_STEPS,
            ScrollStep::Pages => ffi::GTK_SCROLL_PAGES,
            ScrollStep::Ends => ffi::GTK_SCROLL_ENDS,
            ScrollStep::HorizontalSteps => ffi::GTK_SCROLL_HORIZONTAL_STEPS,
            ScrollStep::HorizontalPages => ffi::GTK_SCROLL_HORIZONTAL_PAGES,
            ScrollStep::HorizontalEnds => ffi::GTK_SCROLL_HORIZONTAL_ENDS,
            ScrollStep::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkScrollStep> for ScrollStep {
    fn from_glib(value: ffi::GtkScrollStep) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_SCROLL_STEPS => ScrollStep::Steps,
            ffi::GTK_SCROLL_PAGES => ScrollStep::Pages,
            ffi::GTK_SCROLL_ENDS => ScrollStep::Ends,
            ffi::GTK_SCROLL_HORIZONTAL_STEPS => ScrollStep::HorizontalSteps,
            ffi::GTK_SCROLL_HORIZONTAL_PAGES => ScrollStep::HorizontalPages,
            ffi::GTK_SCROLL_HORIZONTAL_ENDS => ScrollStep::HorizontalEnds,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ScrollType {
    None,
    Jump,
    StepBackward,
    StepForward,
    PageBackward,
    PageForward,
    StepUp,
    StepDown,
    PageUp,
    PageDown,
    StepLeft,
    StepRight,
    PageLeft,
    PageRight,
    Start,
    End,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for ScrollType {
    type GlibType = ffi::GtkScrollType;

    fn to_glib(&self) -> ffi::GtkScrollType {
        match *self {
            ScrollType::None => ffi::GTK_SCROLL_NONE,
            ScrollType::Jump => ffi::GTK_SCROLL_JUMP,
            ScrollType::StepBackward => ffi::GTK_SCROLL_STEP_BACKWARD,
            ScrollType::StepForward => ffi::GTK_SCROLL_STEP_FORWARD,
            ScrollType::PageBackward => ffi::GTK_SCROLL_PAGE_BACKWARD,
            ScrollType::PageForward => ffi::GTK_SCROLL_PAGE_FORWARD,
            ScrollType::StepUp => ffi::GTK_SCROLL_STEP_UP,
            ScrollType::StepDown => ffi::GTK_SCROLL_STEP_DOWN,
            ScrollType::PageUp => ffi::GTK_SCROLL_PAGE_UP,
            ScrollType::PageDown => ffi::GTK_SCROLL_PAGE_DOWN,
            ScrollType::StepLeft => ffi::GTK_SCROLL_STEP_LEFT,
            ScrollType::StepRight => ffi::GTK_SCROLL_STEP_RIGHT,
            ScrollType::PageLeft => ffi::GTK_SCROLL_PAGE_LEFT,
            ScrollType::PageRight => ffi::GTK_SCROLL_PAGE_RIGHT,
            ScrollType::Start => ffi::GTK_SCROLL_START,
            ScrollType::End => ffi::GTK_SCROLL_END,
            ScrollType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkScrollType> for ScrollType {
    fn from_glib(value: ffi::GtkScrollType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_SCROLL_NONE => ScrollType::None,
            ffi::GTK_SCROLL_JUMP => ScrollType::Jump,
            ffi::GTK_SCROLL_STEP_BACKWARD => ScrollType::StepBackward,
            ffi::GTK_SCROLL_STEP_FORWARD => ScrollType::StepForward,
            ffi::GTK_SCROLL_PAGE_BACKWARD => ScrollType::PageBackward,
            ffi::GTK_SCROLL_PAGE_FORWARD => ScrollType::PageForward,
            ffi::GTK_SCROLL_STEP_UP => ScrollType::StepUp,
            ffi::GTK_SCROLL_STEP_DOWN => ScrollType::StepDown,
            ffi::GTK_SCROLL_PAGE_UP => ScrollType::PageUp,
            ffi::GTK_SCROLL_PAGE_DOWN => ScrollType::PageDown,
            ffi::GTK_SCROLL_STEP_LEFT => ScrollType::StepLeft,
            ffi::GTK_SCROLL_STEP_RIGHT => ScrollType::StepRight,
            ffi::GTK_SCROLL_PAGE_LEFT => ScrollType::PageLeft,
            ffi::GTK_SCROLL_PAGE_RIGHT => ScrollType::PageRight,
            ffi::GTK_SCROLL_START => ScrollType::Start,
            ffi::GTK_SCROLL_END => ScrollType::End,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ScrollablePolicy {
    Minimum,
    Natural,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for ScrollablePolicy {
    type GlibType = ffi::GtkScrollablePolicy;

    fn to_glib(&self) -> ffi::GtkScrollablePolicy {
        match *self {
            ScrollablePolicy::Minimum => ffi::GTK_SCROLL_MINIMUM,
            ScrollablePolicy::Natural => ffi::GTK_SCROLL_NATURAL,
            ScrollablePolicy::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkScrollablePolicy> for ScrollablePolicy {
    fn from_glib(value: ffi::GtkScrollablePolicy) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_SCROLL_MINIMUM => ScrollablePolicy::Minimum,
            ffi::GTK_SCROLL_NATURAL => ScrollablePolicy::Natural,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum SelectionMode {
    None,
    Single,
    Browse,
    Multiple,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for SelectionMode {
    type GlibType = ffi::GtkSelectionMode;

    fn to_glib(&self) -> ffi::GtkSelectionMode {
        match *self {
            SelectionMode::None => ffi::GTK_SELECTION_NONE,
            SelectionMode::Single => ffi::GTK_SELECTION_SINGLE,
            SelectionMode::Browse => ffi::GTK_SELECTION_BROWSE,
            SelectionMode::Multiple => ffi::GTK_SELECTION_MULTIPLE,
            SelectionMode::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSelectionMode> for SelectionMode {
    fn from_glib(value: ffi::GtkSelectionMode) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_SELECTION_NONE => SelectionMode::None,
            ffi::GTK_SELECTION_SINGLE => SelectionMode::Single,
            ffi::GTK_SELECTION_BROWSE => SelectionMode::Browse,
            ffi::GTK_SELECTION_MULTIPLE => SelectionMode::Multiple,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum SensitivityType {
    Auto,
    On,
    Off,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for SensitivityType {
    type GlibType = ffi::GtkSensitivityType;

    fn to_glib(&self) -> ffi::GtkSensitivityType {
        match *self {
            SensitivityType::Auto => ffi::GTK_SENSITIVITY_AUTO,
            SensitivityType::On => ffi::GTK_SENSITIVITY_ON,
            SensitivityType::Off => ffi::GTK_SENSITIVITY_OFF,
            SensitivityType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSensitivityType> for SensitivityType {
    fn from_glib(value: ffi::GtkSensitivityType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_SENSITIVITY_AUTO => SensitivityType::Auto,
            ffi::GTK_SENSITIVITY_ON => SensitivityType::On,
            ffi::GTK_SENSITIVITY_OFF => SensitivityType::Off,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ShadowType {
    None,
    In,
    Out,
    EtchedIn,
    EtchedOut,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for ShadowType {
    type GlibType = ffi::GtkShadowType;

    fn to_glib(&self) -> ffi::GtkShadowType {
        match *self {
            ShadowType::None => ffi::GTK_SHADOW_NONE,
            ShadowType::In => ffi::GTK_SHADOW_IN,
            ShadowType::Out => ffi::GTK_SHADOW_OUT,
            ShadowType::EtchedIn => ffi::GTK_SHADOW_ETCHED_IN,
            ShadowType::EtchedOut => ffi::GTK_SHADOW_ETCHED_OUT,
            ShadowType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkShadowType> for ShadowType {
    fn from_glib(value: ffi::GtkShadowType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_SHADOW_NONE => ShadowType::None,
            ffi::GTK_SHADOW_IN => ShadowType::In,
            ffi::GTK_SHADOW_OUT => ShadowType::Out,
            ffi::GTK_SHADOW_ETCHED_IN => ShadowType::EtchedIn,
            ffi::GTK_SHADOW_ETCHED_OUT => ShadowType::EtchedOut,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum SizeGroupMode {
    None,
    Horizontal,
    Vertical,
    Both,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for SizeGroupMode {
    type GlibType = ffi::GtkSizeGroupMode;

    fn to_glib(&self) -> ffi::GtkSizeGroupMode {
        match *self {
            SizeGroupMode::None => ffi::GTK_SIZE_GROUP_NONE,
            SizeGroupMode::Horizontal => ffi::GTK_SIZE_GROUP_HORIZONTAL,
            SizeGroupMode::Vertical => ffi::GTK_SIZE_GROUP_VERTICAL,
            SizeGroupMode::Both => ffi::GTK_SIZE_GROUP_BOTH,
            SizeGroupMode::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSizeGroupMode> for SizeGroupMode {
    fn from_glib(value: ffi::GtkSizeGroupMode) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_SIZE_GROUP_NONE => SizeGroupMode::None,
            ffi::GTK_SIZE_GROUP_HORIZONTAL => SizeGroupMode::Horizontal,
            ffi::GTK_SIZE_GROUP_VERTICAL => SizeGroupMode::Vertical,
            ffi::GTK_SIZE_GROUP_BOTH => SizeGroupMode::Both,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum SizeRequestMode {
    HeightForWidth,
    WidthForHeight,
    ConstantSize,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for SizeRequestMode {
    type GlibType = ffi::GtkSizeRequestMode;

    fn to_glib(&self) -> ffi::GtkSizeRequestMode {
        match *self {
            SizeRequestMode::HeightForWidth => ffi::GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH,
            SizeRequestMode::WidthForHeight => ffi::GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT,
            SizeRequestMode::ConstantSize => ffi::GTK_SIZE_REQUEST_CONSTANT_SIZE,
            SizeRequestMode::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSizeRequestMode> for SizeRequestMode {
    fn from_glib(value: ffi::GtkSizeRequestMode) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH => SizeRequestMode::HeightForWidth,
            ffi::GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT => SizeRequestMode::WidthForHeight,
            ffi::GTK_SIZE_REQUEST_CONSTANT_SIZE => SizeRequestMode::ConstantSize,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum SortType {
    Ascending,
    Descending,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for SortType {
    type GlibType = ffi::GtkSortType;

    fn to_glib(&self) -> ffi::GtkSortType {
        match *self {
            SortType::Ascending => ffi::GTK_SORT_ASCENDING,
            SortType::Descending => ffi::GTK_SORT_DESCENDING,
            SortType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSortType> for SortType {
    fn from_glib(value: ffi::GtkSortType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_SORT_ASCENDING => SortType::Ascending,
            ffi::GTK_SORT_DESCENDING => SortType::Descending,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum SpinButtonUpdatePolicy {
    Always,
    IfValid,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for SpinButtonUpdatePolicy {
    type GlibType = ffi::GtkSpinButtonUpdatePolicy;

    fn to_glib(&self) -> ffi::GtkSpinButtonUpdatePolicy {
        match *self {
            SpinButtonUpdatePolicy::Always => ffi::GTK_UPDATE_ALWAYS,
            SpinButtonUpdatePolicy::IfValid => ffi::GTK_UPDATE_IF_VALID,
            SpinButtonUpdatePolicy::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSpinButtonUpdatePolicy> for SpinButtonUpdatePolicy {
    fn from_glib(value: ffi::GtkSpinButtonUpdatePolicy) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_UPDATE_ALWAYS => SpinButtonUpdatePolicy::Always,
            ffi::GTK_UPDATE_IF_VALID => SpinButtonUpdatePolicy::IfValid,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum SpinType {
    StepForward,
    StepBackward,
    PageForward,
    PageBackward,
    Home,
    End,
    UserDefined,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for SpinType {
    type GlibType = ffi::GtkSpinType;

    fn to_glib(&self) -> ffi::GtkSpinType {
        match *self {
            SpinType::StepForward => ffi::GTK_SPIN_STEP_FORWARD,
            SpinType::StepBackward => ffi::GTK_SPIN_STEP_BACKWARD,
            SpinType::PageForward => ffi::GTK_SPIN_PAGE_FORWARD,
            SpinType::PageBackward => ffi::GTK_SPIN_PAGE_BACKWARD,
            SpinType::Home => ffi::GTK_SPIN_HOME,
            SpinType::End => ffi::GTK_SPIN_END,
            SpinType::UserDefined => ffi::GTK_SPIN_USER_DEFINED,
            SpinType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSpinType> for SpinType {
    fn from_glib(value: ffi::GtkSpinType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_SPIN_STEP_FORWARD => SpinType::StepForward,
            ffi::GTK_SPIN_STEP_BACKWARD => SpinType::StepBackward,
            ffi::GTK_SPIN_PAGE_FORWARD => SpinType::PageForward,
            ffi::GTK_SPIN_PAGE_BACKWARD => SpinType::PageBackward,
            ffi::GTK_SPIN_HOME => SpinType::Home,
            ffi::GTK_SPIN_END => SpinType::End,
            ffi::GTK_SPIN_USER_DEFINED => SpinType::UserDefined,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum StackTransitionType {
    None,
    Crossfade,
    SlideRight,
    SlideLeft,
    SlideUp,
    SlideDown,
    SlideLeftRight,
    SlideUpDown,
    OverUp,
    OverDown,
    OverLeft,
    OverRight,
    UnderUp,
    UnderDown,
    UnderLeft,
    UnderRight,
    OverUpDown,
    OverDownUp,
    OverLeftRight,
    OverRightLeft,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for StackTransitionType {
    type GlibType = ffi::GtkStackTransitionType;

    fn to_glib(&self) -> ffi::GtkStackTransitionType {
        match *self {
            StackTransitionType::None => ffi::GTK_STACK_TRANSITION_TYPE_NONE,
            StackTransitionType::Crossfade => ffi::GTK_STACK_TRANSITION_TYPE_CROSSFADE,
            StackTransitionType::SlideRight => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_RIGHT,
            StackTransitionType::SlideLeft => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT,
            StackTransitionType::SlideUp => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_UP,
            StackTransitionType::SlideDown => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_DOWN,
            StackTransitionType::SlideLeftRight => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT_RIGHT,
            StackTransitionType::SlideUpDown => ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_UP_DOWN,
            StackTransitionType::OverUp => ffi::GTK_STACK_TRANSITION_TYPE_OVER_UP,
            StackTransitionType::OverDown => ffi::GTK_STACK_TRANSITION_TYPE_OVER_DOWN,
            StackTransitionType::OverLeft => ffi::GTK_STACK_TRANSITION_TYPE_OVER_LEFT,
            StackTransitionType::OverRight => ffi::GTK_STACK_TRANSITION_TYPE_OVER_RIGHT,
            StackTransitionType::UnderUp => ffi::GTK_STACK_TRANSITION_TYPE_UNDER_UP,
            StackTransitionType::UnderDown => ffi::GTK_STACK_TRANSITION_TYPE_UNDER_DOWN,
            StackTransitionType::UnderLeft => ffi::GTK_STACK_TRANSITION_TYPE_UNDER_LEFT,
            StackTransitionType::UnderRight => ffi::GTK_STACK_TRANSITION_TYPE_UNDER_RIGHT,
            StackTransitionType::OverUpDown => ffi::GTK_STACK_TRANSITION_TYPE_OVER_UP_DOWN,
            StackTransitionType::OverDownUp => ffi::GTK_STACK_TRANSITION_TYPE_OVER_DOWN_UP,
            StackTransitionType::OverLeftRight => ffi::GTK_STACK_TRANSITION_TYPE_OVER_LEFT_RIGHT,
            StackTransitionType::OverRightLeft => ffi::GTK_STACK_TRANSITION_TYPE_OVER_RIGHT_LEFT,
            StackTransitionType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkStackTransitionType> for StackTransitionType {
    fn from_glib(value: ffi::GtkStackTransitionType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_STACK_TRANSITION_TYPE_NONE => StackTransitionType::None,
            ffi::GTK_STACK_TRANSITION_TYPE_CROSSFADE => StackTransitionType::Crossfade,
            ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_RIGHT => StackTransitionType::SlideRight,
            ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT => StackTransitionType::SlideLeft,
            ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_UP => StackTransitionType::SlideUp,
            ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_DOWN => StackTransitionType::SlideDown,
            ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT_RIGHT => StackTransitionType::SlideLeftRight,
            ffi::GTK_STACK_TRANSITION_TYPE_SLIDE_UP_DOWN => StackTransitionType::SlideUpDown,
            ffi::GTK_STACK_TRANSITION_TYPE_OVER_UP => StackTransitionType::OverUp,
            ffi::GTK_STACK_TRANSITION_TYPE_OVER_DOWN => StackTransitionType::OverDown,
            ffi::GTK_STACK_TRANSITION_TYPE_OVER_LEFT => StackTransitionType::OverLeft,
            ffi::GTK_STACK_TRANSITION_TYPE_OVER_RIGHT => StackTransitionType::OverRight,
            ffi::GTK_STACK_TRANSITION_TYPE_UNDER_UP => StackTransitionType::UnderUp,
            ffi::GTK_STACK_TRANSITION_TYPE_UNDER_DOWN => StackTransitionType::UnderDown,
            ffi::GTK_STACK_TRANSITION_TYPE_UNDER_LEFT => StackTransitionType::UnderLeft,
            ffi::GTK_STACK_TRANSITION_TYPE_UNDER_RIGHT => StackTransitionType::UnderRight,
            ffi::GTK_STACK_TRANSITION_TYPE_OVER_UP_DOWN => StackTransitionType::OverUpDown,
            ffi::GTK_STACK_TRANSITION_TYPE_OVER_DOWN_UP => StackTransitionType::OverDownUp,
            ffi::GTK_STACK_TRANSITION_TYPE_OVER_LEFT_RIGHT => StackTransitionType::OverLeftRight,
            ffi::GTK_STACK_TRANSITION_TYPE_OVER_RIGHT_LEFT => StackTransitionType::OverRightLeft,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum StateType {
    Normal,
    Active,
    Prelight,
    Selected,
    Insensitive,
    Inconsistent,
    Focused,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for StateType {
    type GlibType = ffi::GtkStateType;

    fn to_glib(&self) -> ffi::GtkStateType {
        match *self {
            StateType::Normal => ffi::GTK_STATE_NORMAL,
            StateType::Active => ffi::GTK_STATE_ACTIVE,
            StateType::Prelight => ffi::GTK_STATE_PRELIGHT,
            StateType::Selected => ffi::GTK_STATE_SELECTED,
            StateType::Insensitive => ffi::GTK_STATE_INSENSITIVE,
            StateType::Inconsistent => ffi::GTK_STATE_INCONSISTENT,
            StateType::Focused => ffi::GTK_STATE_FOCUSED,
            StateType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkStateType> for StateType {
    fn from_glib(value: ffi::GtkStateType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_STATE_NORMAL => StateType::Normal,
            ffi::GTK_STATE_ACTIVE => StateType::Active,
            ffi::GTK_STATE_PRELIGHT => StateType::Prelight,
            ffi::GTK_STATE_SELECTED => StateType::Selected,
            ffi::GTK_STATE_INSENSITIVE => StateType::Insensitive,
            ffi::GTK_STATE_INCONSISTENT => StateType::Inconsistent,
            ffi::GTK_STATE_FOCUSED => StateType::Focused,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum TextDirection {
    None,
    Ltr,
    Rtl,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for TextDirection {
    type GlibType = ffi::GtkTextDirection;

    fn to_glib(&self) -> ffi::GtkTextDirection {
        match *self {
            TextDirection::None => ffi::GTK_TEXT_DIR_NONE,
            TextDirection::Ltr => ffi::GTK_TEXT_DIR_LTR,
            TextDirection::Rtl => ffi::GTK_TEXT_DIR_RTL,
            TextDirection::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTextDirection> for TextDirection {
    fn from_glib(value: ffi::GtkTextDirection) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_TEXT_DIR_NONE => TextDirection::None,
            ffi::GTK_TEXT_DIR_LTR => TextDirection::Ltr,
            ffi::GTK_TEXT_DIR_RTL => TextDirection::Rtl,
        }
    }
}

#[cfg(feature = "v3_16")]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum TextExtendSelection {
    Word,
    Line,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[cfg(feature = "v3_16")]
#[doc(hidden)]
impl ToGlib for TextExtendSelection {
    type GlibType = ffi::GtkTextExtendSelection;

    fn to_glib(&self) -> ffi::GtkTextExtendSelection {
        match *self {
            TextExtendSelection::Word => ffi::GTK_TEXT_EXTEND_SELECTION_WORD,
            TextExtendSelection::Line => ffi::GTK_TEXT_EXTEND_SELECTION_LINE,
            TextExtendSelection::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[cfg(feature = "v3_16")]
#[doc(hidden)]
impl FromGlib<ffi::GtkTextExtendSelection> for TextExtendSelection {
    fn from_glib(value: ffi::GtkTextExtendSelection) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_TEXT_EXTEND_SELECTION_WORD => TextExtendSelection::Word,
            ffi::GTK_TEXT_EXTEND_SELECTION_LINE => TextExtendSelection::Line,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum TextWindowType {
    Private,
    Widget,
    Text,
    Left,
    Right,
    Top,
    Bottom,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for TextWindowType {
    type GlibType = ffi::GtkTextWindowType;

    fn to_glib(&self) -> ffi::GtkTextWindowType {
        match *self {
            TextWindowType::Private => ffi::GTK_TEXT_WINDOW_PRIVATE,
            TextWindowType::Widget => ffi::GTK_TEXT_WINDOW_WIDGET,
            TextWindowType::Text => ffi::GTK_TEXT_WINDOW_TEXT,
            TextWindowType::Left => ffi::GTK_TEXT_WINDOW_LEFT,
            TextWindowType::Right => ffi::GTK_TEXT_WINDOW_RIGHT,
            TextWindowType::Top => ffi::GTK_TEXT_WINDOW_TOP,
            TextWindowType::Bottom => ffi::GTK_TEXT_WINDOW_BOTTOM,
            TextWindowType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTextWindowType> for TextWindowType {
    fn from_glib(value: ffi::GtkTextWindowType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_TEXT_WINDOW_PRIVATE => TextWindowType::Private,
            ffi::GTK_TEXT_WINDOW_WIDGET => TextWindowType::Widget,
            ffi::GTK_TEXT_WINDOW_TEXT => TextWindowType::Text,
            ffi::GTK_TEXT_WINDOW_LEFT => TextWindowType::Left,
            ffi::GTK_TEXT_WINDOW_RIGHT => TextWindowType::Right,
            ffi::GTK_TEXT_WINDOW_TOP => TextWindowType::Top,
            ffi::GTK_TEXT_WINDOW_BOTTOM => TextWindowType::Bottom,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ToolbarStyle {
    Icons,
    Text,
    Both,
    BothHoriz,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for ToolbarStyle {
    type GlibType = ffi::GtkToolbarStyle;

    fn to_glib(&self) -> ffi::GtkToolbarStyle {
        match *self {
            ToolbarStyle::Icons => ffi::GTK_TOOLBAR_ICONS,
            ToolbarStyle::Text => ffi::GTK_TOOLBAR_TEXT,
            ToolbarStyle::Both => ffi::GTK_TOOLBAR_BOTH,
            ToolbarStyle::BothHoriz => ffi::GTK_TOOLBAR_BOTH_HORIZ,
            ToolbarStyle::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkToolbarStyle> for ToolbarStyle {
    fn from_glib(value: ffi::GtkToolbarStyle) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_TOOLBAR_ICONS => ToolbarStyle::Icons,
            ffi::GTK_TOOLBAR_TEXT => ToolbarStyle::Text,
            ffi::GTK_TOOLBAR_BOTH => ToolbarStyle::Both,
            ffi::GTK_TOOLBAR_BOTH_HORIZ => ToolbarStyle::BothHoriz,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum TreeViewColumnSizing {
    GrowOnly,
    Autosize,
    Fixed,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for TreeViewColumnSizing {
    type GlibType = ffi::GtkTreeViewColumnSizing;

    fn to_glib(&self) -> ffi::GtkTreeViewColumnSizing {
        match *self {
            TreeViewColumnSizing::GrowOnly => ffi::GTK_TREE_VIEW_COLUMN_GROW_ONLY,
            TreeViewColumnSizing::Autosize => ffi::GTK_TREE_VIEW_COLUMN_AUTOSIZE,
            TreeViewColumnSizing::Fixed => ffi::GTK_TREE_VIEW_COLUMN_FIXED,
            TreeViewColumnSizing::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTreeViewColumnSizing> for TreeViewColumnSizing {
    fn from_glib(value: ffi::GtkTreeViewColumnSizing) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_TREE_VIEW_COLUMN_GROW_ONLY => TreeViewColumnSizing::GrowOnly,
            ffi::GTK_TREE_VIEW_COLUMN_AUTOSIZE => TreeViewColumnSizing::Autosize,
            ffi::GTK_TREE_VIEW_COLUMN_FIXED => TreeViewColumnSizing::Fixed,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum TreeViewDropPosition {
    Before,
    After,
    IntoOrBefore,
    IntoOrAfter,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for TreeViewDropPosition {
    type GlibType = ffi::GtkTreeViewDropPosition;

    fn to_glib(&self) -> ffi::GtkTreeViewDropPosition {
        match *self {
            TreeViewDropPosition::Before => ffi::GTK_TREE_VIEW_DROP_BEFORE,
            TreeViewDropPosition::After => ffi::GTK_TREE_VIEW_DROP_AFTER,
            TreeViewDropPosition::IntoOrBefore => ffi::GTK_TREE_VIEW_DROP_INTO_OR_BEFORE,
            TreeViewDropPosition::IntoOrAfter => ffi::GTK_TREE_VIEW_DROP_INTO_OR_AFTER,
            TreeViewDropPosition::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTreeViewDropPosition> for TreeViewDropPosition {
    fn from_glib(value: ffi::GtkTreeViewDropPosition) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_TREE_VIEW_DROP_BEFORE => TreeViewDropPosition::Before,
            ffi::GTK_TREE_VIEW_DROP_AFTER => TreeViewDropPosition::After,
            ffi::GTK_TREE_VIEW_DROP_INTO_OR_BEFORE => TreeViewDropPosition::IntoOrBefore,
            ffi::GTK_TREE_VIEW_DROP_INTO_OR_AFTER => TreeViewDropPosition::IntoOrAfter,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum TreeViewGridLines {
    None,
    Horizontal,
    Vertical,
    Both,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for TreeViewGridLines {
    type GlibType = ffi::GtkTreeViewGridLines;

    fn to_glib(&self) -> ffi::GtkTreeViewGridLines {
        match *self {
            TreeViewGridLines::None => ffi::GTK_TREE_VIEW_GRID_LINES_NONE,
            TreeViewGridLines::Horizontal => ffi::GTK_TREE_VIEW_GRID_LINES_HORIZONTAL,
            TreeViewGridLines::Vertical => ffi::GTK_TREE_VIEW_GRID_LINES_VERTICAL,
            TreeViewGridLines::Both => ffi::GTK_TREE_VIEW_GRID_LINES_BOTH,
            TreeViewGridLines::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkTreeViewGridLines> for TreeViewGridLines {
    fn from_glib(value: ffi::GtkTreeViewGridLines) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_TREE_VIEW_GRID_LINES_NONE => TreeViewGridLines::None,
            ffi::GTK_TREE_VIEW_GRID_LINES_HORIZONTAL => TreeViewGridLines::Horizontal,
            ffi::GTK_TREE_VIEW_GRID_LINES_VERTICAL => TreeViewGridLines::Vertical,
            ffi::GTK_TREE_VIEW_GRID_LINES_BOTH => TreeViewGridLines::Both,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum Unit {
    None,
    Points,
    Inch,
    Mm,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for Unit {
    type GlibType = ffi::GtkUnit;

    fn to_glib(&self) -> ffi::GtkUnit {
        match *self {
            Unit::None => ffi::GTK_UNIT_NONE,
            Unit::Points => ffi::GTK_UNIT_POINTS,
            Unit::Inch => ffi::GTK_UNIT_INCH,
            Unit::Mm => ffi::GTK_UNIT_MM,
            Unit::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkUnit> for Unit {
    fn from_glib(value: ffi::GtkUnit) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_UNIT_NONE => Unit::None,
            ffi::GTK_UNIT_POINTS => Unit::Points,
            ffi::GTK_UNIT_INCH => Unit::Inch,
            ffi::GTK_UNIT_MM => Unit::Mm,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum WidgetHelpType {
    Tooltip,
    WhatsThis,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for WidgetHelpType {
    type GlibType = ffi::GtkWidgetHelpType;

    fn to_glib(&self) -> ffi::GtkWidgetHelpType {
        match *self {
            WidgetHelpType::Tooltip => ffi::GTK_WIDGET_HELP_TOOLTIP,
            WidgetHelpType::WhatsThis => ffi::GTK_WIDGET_HELP_WHATS_THIS,
            WidgetHelpType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkWidgetHelpType> for WidgetHelpType {
    fn from_glib(value: ffi::GtkWidgetHelpType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_WIDGET_HELP_TOOLTIP => WidgetHelpType::Tooltip,
            ffi::GTK_WIDGET_HELP_WHATS_THIS => WidgetHelpType::WhatsThis,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum WindowPosition {
    None,
    Center,
    Mouse,
    CenterAlways,
    CenterOnParent,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for WindowPosition {
    type GlibType = ffi::GtkWindowPosition;

    fn to_glib(&self) -> ffi::GtkWindowPosition {
        match *self {
            WindowPosition::None => ffi::GTK_WIN_POS_NONE,
            WindowPosition::Center => ffi::GTK_WIN_POS_CENTER,
            WindowPosition::Mouse => ffi::GTK_WIN_POS_MOUSE,
            WindowPosition::CenterAlways => ffi::GTK_WIN_POS_CENTER_ALWAYS,
            WindowPosition::CenterOnParent => ffi::GTK_WIN_POS_CENTER_ON_PARENT,
            WindowPosition::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkWindowPosition> for WindowPosition {
    fn from_glib(value: ffi::GtkWindowPosition) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_WIN_POS_NONE => WindowPosition::None,
            ffi::GTK_WIN_POS_CENTER => WindowPosition::Center,
            ffi::GTK_WIN_POS_MOUSE => WindowPosition::Mouse,
            ffi::GTK_WIN_POS_CENTER_ALWAYS => WindowPosition::CenterAlways,
            ffi::GTK_WIN_POS_CENTER_ON_PARENT => WindowPosition::CenterOnParent,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum WindowType {
    Toplevel,
    Popup,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for WindowType {
    type GlibType = ffi::GtkWindowType;

    fn to_glib(&self) -> ffi::GtkWindowType {
        match *self {
            WindowType::Toplevel => ffi::GTK_WINDOW_TOPLEVEL,
            WindowType::Popup => ffi::GTK_WINDOW_POPUP,
            WindowType::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkWindowType> for WindowType {
    fn from_glib(value: ffi::GtkWindowType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_WINDOW_TOPLEVEL => WindowType::Toplevel,
            ffi::GTK_WINDOW_POPUP => WindowType::Popup,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum WrapMode {
    None,
    Char,
    Word,
    WordChar,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for WrapMode {
    type GlibType = ffi::GtkWrapMode;

    fn to_glib(&self) -> ffi::GtkWrapMode {
        match *self {
            WrapMode::None => ffi::GTK_WRAP_NONE,
            WrapMode::Char => ffi::GTK_WRAP_CHAR,
            WrapMode::Word => ffi::GTK_WRAP_WORD,
            WrapMode::WordChar => ffi::GTK_WRAP_WORD_CHAR,
            WrapMode::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkWrapMode> for WrapMode {
    fn from_glib(value: ffi::GtkWrapMode) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::GTK_WRAP_NONE => WrapMode::None,
            ffi::GTK_WRAP_CHAR => WrapMode::Char,
            ffi::GTK_WRAP_WORD => WrapMode::Word,
            ffi::GTK_WRAP_WORD_CHAR => WrapMode::WordChar,
        }
    }
}

